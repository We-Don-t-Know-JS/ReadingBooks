# 문법

자바스크립트 문법은 각종 구문(연산자, 키워드 등)들을 서로 잘 끼워 맞춰 규칙에 맞는 유효한 프로그램을 만들기 위한 구조적 방법이다.

## 문과 표현식

### 문법

- 문장: 생각을 표현하는 단어들의 완전한 조형물
- 어구: 하나 이상의 어구로 문장이 구성됨.
  어구는 구두점이나 접속사로 연결할 수 있다.
  어구는 더 작은 어구로 나눌 수 있다.
  어떤 어구는 불완전해 그 자체로 완성된 문장을 혀성할 수 없음.
  어떤 어구는 스스로의 힘만으로도 완성됨.

자바스크립트 문법도 동일함.

- 문장 == 문
- 어구 == 표현식
- 연산자 == 구두점, 접속사

자바스크립트에서 모든 표현식은 단일한, 특정한 결괏값으로 계산된다.

```js
var a = 3 * 6;
var b = a;
b;
```

3\*6; => 표현식
b=a; => 표현식
b; => 표현식

**선언문**

```js
var a = 3 * 6;
var b = a;
```

위 두 문장은 할당과 동시에 변수를 선언, 그리고 선택적으로 할당함으로 선언문이다.

**할당 표현식**

```js
a = 3 * 6;
b = a;
```

앞에 `var`가 빠진 위 두 문장은 할당 표현식이다.

**표현식 문**

```js
b;
```

위 문장은 `b`가 표현식의 전부지만 이것만으로도 완전한 문이다. 이를 표현식 문 이라고 일컫는다.

### 문의 완료 값

> 문 도입부에 문의 평과 결과는 항상 완료값이다.
> 모든 문은 그 값이 undefined라고 해도 완료값을 가진다.

`var b = a`같은 문의 완료 값은 뭘까?
b = a는 할당 이후의 값이 완료 값이지만, var 문 자체의 완료값은 undefined이다. 명세에 그렇게 적혀있다. 콘솔에서 실행 시 undefined가 나타나는 이유다.

> Variable Declaration 알고리즘은 실제로 어떤 값을 반환하지만, 이 값은 (for in 루프에서 사용할 경우를 제외하곤) VariableStatement 알고리즘이 삼킨 후 텅 빈 undefined 완료 값을 내놓는다. (ES5 12.2)

블록의 완료 값은 내부에 있는 마지막 문의 값을 암시적으로 반환한 값이다.

```js
var b; //undefined

if (true) {
  b = 4 + 38;
} // 42

if (true) {
  b = 4 + 38;
  console.log("야호");
} // 야호, 마지막 문 반환
```

문의 완료 값을 포착하는 방법으로는 `eval()`함수를 쓰는 방법이 있다. 그렇지만 이는 매우 유해한 함수이다. ES7명세에 do 표현식이 있으므로 이를 사용하도록 하자.

`do { }` 표현식은 하나 이상의 문을 포함한 블록 실행 후 블록 내 마지막 문의 완료 값을 do 표현식 전체의 완료값으로 반환해, 결국 이 값이 변수 a에 할당된다. 이는 아직 도입되진 않았다.

### 표현식의 부수 효과

부수 효과를 가진 표현식

```js
var a = 42;
var b = a++;

a; // 43
b; // 42
```

표현식 `a++`이 하는 일

1. a의 현재 값 42를 반환
2. 그리고 b에 할당
3. a값을 1만큼 증가시킴

b 값을 43으로 착각하는 경우가 있다.

**++ 연산자**

단항 연산자인 증가 연산자/감소 연산자는 전위 또는 후위 연산자로 사용된다.

```js
var a = 42;

a++; // 42
a; // 43

++a; // 44
a; // 44
```

++를 전위 연산자로 사용하면 표현식으로부터 값이 반환되기 전에 a값을 1만큼 증가시키는 부수 효과를 일으킨다. 반면, 후위 연산자로 사용하면 값을 반환한 이후에 부수 효과가 발생한다.

부수 효과를 유발하는 연산자는 부수 효과를 일으킬 변수 레퍼런스가 꼭 필요하다. 없으면 ReferenceError가 난다.

**delete 연산자**

delete 역시 부수효과를 일으키는 연산자다. 이 연산자의 부수 효과는 바로 프로퍼티, 또는 배열 슬롯을 제거하는 것아다,

**=할당 연산자**

```js
var a;

a = 42; // 42
a; // 42
```

`a = 42`에서 = 연산자는 부수효과를 일으킨다. (42를 a에 할당하는 부수효과를 일으킨다.)
`a = 42`문의 실행 결과는 이제 막 할당된 값(42)이므로 42를 a에 할당하는 자체가 본질적으로 부수효과다.
+=, -= 등의 복합 할당 연산자 역시 부수효과를 지닌다. 예를 들어, `a = b += 2` 문에서 `b += 2`이 먼저 처리되고 = 연산자가 그 결괏값을 a에 할당한다.

## 콘텍스트 규칙

자바스크립트 문법 규칙 중에는 같은 구문이지만 어디에서 어떤 식으로 사용하느냐에 따라 서로 다른 의미를 가지는 경우가 있다.

### 중괄호 { }

자바스크립트에서 중괄호가 나올 법한 곳은 크게 두 군데다.

**객체 리터럴**

```js
// bar() 함수는 앞에서 정의되었음.

var a = {
  foo: bar();
}
```

**레이블**

```js
// bar() 함수는 앞에서 정의되었음.

{
  foo: bar();
}
```

앞서 `var a =`부분을 삭제하면, { }는 어디에도 할당되지 않은 그저 고립된 객체 리터럴처럼 보인다. 하지만 전혀 그렇지 않다. **여기서의 { }는 평범한 코드 블록이다.** 문법적으로는 100% 옳은 코드이다. 특히 let 블록 스코프 선언과 함께 쓰이면 아주 유용하다.

이 코드 블록은 for/while 루프, if 조건 등에 붙어있는 코드 블록과 기능적으로 매우 유사하다.

그저 평범한 코드 블록에 불과하면 어떻게 이 코드가 문법에 부합하다는 걸까?

이는 레이블 문(Labled Statement)라고 부르는 기능 덕분이다. 즉, **foo는 bar()문의 레이블**이다.

자바스크립트는 goto를 사용하지 않는다. 그러나 레이블 점프라는 특별한 형태의 장치가 있다. continue와 break문은 선택적으로 어떤 레이블을 받아 goto처럼 프로그램의 실행 흐름을 점프시킨다.

continue는 "ㅇㅇ라는 레이블 위치로 이동해 계속 순회하라"는 아니가 아니라 "ㅇㅇ라는 레이블이 붙은 루프의 다음 순회를 계속하라"라는 뜻이다.

break는 "ㅇㅇ라는 레이블 위치로 이동해 계속 순회하라"가 아니라 "레이블이 붙은 바깥족 루프/블록 밖으로 나가 그 이후부터 계속하라"라는 뜻이다.

레이블은 비 루프 블록에 적용할 수 있다. 단 이런 비 루프 레이블은 break만 참조할 수 있다.
break를 사용해 레이블 블록 밖으로 나갈 수는 있지만, 비 루프 블록을 continue한다던가, 레이블 없는 vreak로 블록은 빠져나올 순 없다.

**JSON**

JSON은 자바스크립트 구문의 하위 집합이다. 고유의 하위 집합은 아니다.
자바스크립트 문의 레이블은 따옴표로 감싸면 안 되기 때문에 "a"는 문법에 맞는 레이블이 아니며, : 뒤에 오면 안 된다.

JSON을 `<script src="">` 태그로 읽어 들여도 정상적인 자바스크립트 코드로 인식될거라는 예상을 한다. 그러나 이 파일은 접근할 수 없다. 이때 JSON-P (JSON 데이터를 `foo({"a": 42})` 같은 함수 호출로 감싸는 패턴) 방식으로 자바스크립트 함수 중 하나에 이 값을 인자로 실어 보내면 해결할 수 있다고 한다.

하지만 실은 그렇지 않다.
{"a": 42}는 완전히 올바른 JSON 값이지만, 그 자체로는 레이블이 잘못된 문 블록으로 해석되어 에러가 난다.
하지만 foo({"a": 42})는 함수 내부에서 {"a": 42}이 foo()에 전달된 객체 리터럴이므로 유효한 자바스크립트 코드다.
JSON-P는 JSON을 문법에 맞는 자바스크립트 코드로 옷을 갈아입혀주는 셈이다.

## 블록

```js
[] + {}; // "[object Object]"
{
}
+[]; // 0
```

윗 줄에서 엔진은 + 연산자 표현식의 {}를 실제 값(빈 객체)로 해석한다.
[]는 " "로 강제변환 되고 {}도 문자열 "[object Object]"로 강제변환 된다.

아랫 줄의 {}는 동떨어진, 아무 일도 하지 않는 빈 블록으로 간주한다.
결국 + [] 표현식에서 명시적으로 [] 를 숫자 0으로 강제변환한다.

{ }은 전적으로 사용 콘텍스트에 따라 의미가 결정되는데, 객체 분해(비구조화 할당)을 통해 문법과 구문의 차이점을 엿볼 수 있다.

### else if

자바스크립트에서 else if 같은 건 없다. 자바스크립트 문법의 숨겨진 특성이다.
if와 else문은 실행이 하나밖에 없는 경우 블록을 감싸는 { }를 생략해도 된다.
그러나 정확히 동일한 문법 규칙이 else 절에도 적용되어 else if는 실제로는 항상 이렇게 파싱된다.

```js
if (a) {
  // ...
} else {
  if (b) {
    // ...
  } else {
    // ...
  }
}
```

else 이후의 if (b) { } else { }는 단일 문이므로 { }로 감싸든 말든 상관없다.
즉, else if라고 쓰는 건 표준 스타일 가이드 위반 사례가 되며, 단일 if 문과 같이 else를 정의한 셈이 된다.

## 연산자 우선순위

자바스크립트에서 &&, || 연산자는 단순히 true/false를 반환하는 게 아니라, 피연산자 중 하나를 선택해 반환한다.
이때 연산자와 피연산자가 여러개면 어떻게 될까?
이런 규칙을 연산자 우선순위라고 한다.

```js
var a = 42,
  b;
b = (a++, a);

a; // 43
b; // 43
```

```js
var a = 42,
  b;
(b = a++), a;

a; // 43
b; // 43
```

여기서 ( )를 없애면 b의 값이 바뀐다.
이는 `,` 연산자가 `=` 연산자보다 우선순위가 낮기 때문이다.
그러므로 `b = a++, a`를 엔진은 `(b = a++), a`로 해석한다.
a++는 ++ 연산자가 a 값을 변경하는 부수 효과를 일으키기 전에 b에 42값을 할당한다.
다수의 문을 연결하는 연산자로 `,`를 사용할 때에는 이 연산자의 우선순위가 최하위라는 사실을 알아야 한다. 즉, 어떤 연산자라도 `,`보다 먼저 묶인다.

```js
if (str && (matches = str.match(/[aeiou]/g))) {
  // code
}
```

할당문 양쪽을 ( )로 감싸야 한다.
&&가 =보다 우선순위가 높으므로 묶지 않으면 표현식은 `(str && matches) = str.match ...`로 처리된다.

```js
(false && true) || true; // true
false && (true || true); // false
```

```js
(false && true) || true; // true
(false && true) || true; // true
```

```js
true || (false && false); // true

(true || false) && false; // false
true || (false && false); // true
```

&& 연산자가 먼저 평가되고 || 연산자가 그 다음에 평가된다.
**&&는 언제나 ||보다 먼저 평가된다**는 사실이 증명되었다.

연산자 우선순위에 대한 레퍼런스

> https://goo.gl/V1aikc

### 단락 평가

&&, || 연산자는 좌측 피연산자의 평가 결과만으로 전체 결과가 이미 결정될 경우 우측 피연산자의 평가를 건너뛴다. 그래서 '단락' 이라는 말이 유래된다.

예를 들어 a && b에서 a가 falsy면 b는 쳐다보지도 않는다.
마찬가지로 a || b 에서 a가 truthy면, b는 관심을 두지 않는다.

단락 평가는 아주 유용하고 자주 쓰인다.

```js
function doSomething(opts) {
  if (opts && opts.cool) {
    // ..
  }
}
```

여기서 opts는 일종의; 가드다. 만약 opts가 존재한다면, opts.cool표현식은 에러일 수 밖에 없다.
일단 opts를 먼저 단락평가 해 보고, 그 결과가 실패면 opts.cool이면 자동으로 건너뛰니 결과적으로 에러는 나지 않는다.

### 끈끈한 우정

```js
"a && b || c ? c || b ? a : c && b : a";
// 이 코드는 다음과 같다.
"(a && b) || c ? (c || b ? a : c && b) : a";
```

삼항 연산자(? :)는 &&와 || 보다 우선순위가 낮다.
`(a && b || c)`가 `? :`보다 먼저 평가 된다.
즉, &&와 ||는 ? : 보다 서로 더 끈끈한 우정을 나눈 사이라고 할 수 있다.

### 결합성

연산자 우선순위 규칙에 의거해 &&와 ||는 ? : 보다 먼저 묶인다.
그럼 우선순위가 동일한 다수의 연산자라면 처리 순서가 어떻게 될까?
일반적으로 연산자는 좌측부터 그룹핑이 일어나는지 우측부터 그룹핑이 일어나는지에 따라 좌측 결합성 또는 우측 결합성을 가진다.

여기서 결합성이라는 문제는 처리 방향이 좌/우냐 하는 문제와는 전혀 다르다. 평가 순서가 아닌, 그룹핑을 한다는 의미다.

a && b && c 같은 표현식에서 암시적인 그룹핑이 발생한다. 즉, a && b && c 중 어느 한 편이 먼저 평가된다.

&&는 좌측부터 결합하므로(||도 같다.) a && b && c는 (a && b) && c와 같다.
설사 우측부터 결합해 a && (b && c)라도 결과는 같다.
동일한 값에 대해 동일한 표현식은 항상 동일한 순서로 평가된다.

모든 연산자가 같진 않다. 결합 방향이 좌/우측 어느 쪽인지에 따라 완전히 다르게 작동하는 연산자가 있다.

**삼항 연산자**

? :는 우측 결합성 연산자이다.

```js
"a ? b : c ? d : e";
// 위 코드는 아래와 같다.
"a ? b : (c ? d : e)";
```

&&와 ||와는 달리, 우측부터 결합하므로 결과가 달라진다.

**=**

=도 우측 결합성(그룹핑) 연산자 중 하나다.

```js
var a, b, c;
a = b = c = 42;
```

`a = b = c = 42`는 `c = 42 => b = ... => a = ...` 순서로 처리된다. 우측부터 결합하기 떄문에 실제로 엔진은 a = (b = (c = 42))처럼 해석한다.

### 분명히 하자

연산자 우선순위/결합성과 손으로 ( )를 감싸 주는 두 방법을 프로그램에 적절히 배합해 쓰자.

## 세미콜론 자동 삽입

ASI: Automatic Semicolon Insertion, 자동 세미콜론 삽입

자바스크립트 프로그램의 세미콜론이 누락된 곳에 엔진이 자동으로 ;을 삽입하는 것.
이런 수고를 대신하는 이유는 단 하나의 ;이라도 누락되면 자바스크립트 프로그램은 돌아가지 않기 때문이다. ;을 안 써도 프로그램이 실행되는 건 ASI 덕분이다.

단, ASI는 새 줄(행 바꿈)에만 적용되며 어떤 경우에도 줄 중간에 삽입되지는 않는다.
기본적으로 자바스크립트 파서는 줄 단위로 파싱을 하다가 ;이 빠져 에러가 나면 ;을 넣어보고 타당한 것 같으면(즉, 문의 끝 부분과 새 줄/행 바꿈 문자 사이에 공란이나 주석밖에 없으면) ;를 삽입한다.

ASI는 주로 break, continue, return, yeild 키워드가 있는 곳에서 활약한다.
ASI는 공식적으로는 구문 오류를 정정하는 프로시저다. ASI는 보편적인 유효 개행 문자 규칙쯤으로 생각하고 코드를 작성하면 안된다.

## 에러

자바스크립트에서 일부 에러는 컴파일 시점에 발생하도록 문법적으로 정의되어 있다. 특히 자바스크립트는 오래 전부터 컴파일 도중 조기 에러로 붙잡아 던지게 되어 있는 여러 가지 특정 조건들이 있었다.

코드가 실행도 되기 전에 발생하므로 이런 에러는 try/catch로 잡을 수 없으며, 그냥 프로그램 파싱/컴파일이 실행된다.

엄격 모드에는 조기 에러가 더 많다.

### 너무 이른 변수 사용

ES6의 새로운 개념, TDZ
TDZ : Temporal Dead Zone, 아직 초기화를 하지 않아 변수를 참조할 수 없는 코드 영역
ES6 let 블록 스코핑이 대표적인 예다.

```js
{
  a = 2; // ReferenceError!
  let a;
}
```

`let a`선언에 의해 초기화되기 전 a = 2 할당문이 블록스코프 안에 있는 변수 a에 접근하려고 한다. 하지만 a는 아직 TDZ내부에 있으므로 에러가 난다.
let a;를 실행 후에 비로소 TDZ가 끝나고 a에 undefined가 할당된다.

typeof 연산자는 선언되지 않은 변수 앞에 붙여도 오류는 나지 않는데 TDZ 참조 시에는 이러한 안정장치가 없다. TDZ 내에 위치해 접근할 수 없으니 typeof 적용하는 것조차 허용되지 않기 때문이다.

```js
{
  typeof a; // undefined
  typeof b; // ReferenceError! (TDZ)
  let b;
}
```

## 함수 인자

TDZ 관련 에러는 ES6 디폴트 인자 값에서도 찾아볼 수 있다.

```js
var b = 3;
function foo(a = 42, b = a + b + 5) {
  // ...
}
```

두 번째 할당문에서 좌변 b는 아직 TDZ에 남아 있는 b를 참조하려고 하기 때문에 더 바깥쪽에서 끌어오지 못하고 에러를 던진다. 그러나 이 시점에서 a는 TDZ를 밟고 간 이후여서 문제가 없다.

함수 인자의 디폴트 값은 마치 하나의 좌측 => 우측 순서로 let 선언을 한 것과 동일하게 처리된다. 그래서 일단 무조건 TDZ에 속하게 된다.

ES6에서 디폴트 인자 값은 함수에 인자를 넘기지 않거나 undefined를 전달했을 떄 적용된다. 그러나 아무런 인자를 넘기지 않은 것과 undefined 인자를 넘기는 것과는 다르다. 아무런 인자를 넘기지 않을 경우 배열에는 원소가 없지만, undefined를 넣으면 배열에도 원소가 추가된다. 이때 추가되는 원소 값은 디폴트 인자 값과 다르다.

인자를 넘기면 arguments의 슬롯과 인자가 연결되면서 항상 같은 값이 할당되지만 인자 없이 호출하면 전혀 연결되지 않는다.

## try ... finally

finally 절의 코드는 어떤 일이 있어도 반드시 실행되고 다른 코드로 넘어가기 전에 try 이후부터 (catch가 있으면 catch 다음부터) 항상 실행된다. 어떤 의미에서 finally 절은 다른 블록 코드에 상관없이 필히 실행되어야 할 콜백 함수와 같다고 봐야 맞다.

try안에 throw가 있어도 비슷하다. 만약 finally 절에서 예외가 던져지면 이전 실행의 결과는 모두 무시한다. 즉, 이전에 try 블록에서 새성한 완료 값이 있어도 완전히 무시된다.

finally 절의 return은 그 이전에 실행된 try나 catch 절의 return을 덮어쓰는 특출한 능력을 갖고 있는데, 단 반드시 명시적으로 return을 써야 한다. 보통 함수에서는 return을 생략해도 return; 또는 return undefined;로 한 셈 치지만, finally 안에서 return을 빼면 이전의 return을 무시하지 않고 존중해 실행한다.

## switch

switch에는 예전에는 몰랐을 기벽이 있다.

1. switch 표현식과 case 표현식 간의 매치 과정은 === 알고리즘과 똑같다. case 문에 확실한 값이 명시된 경우라면 엄격한 매치가 적절하다.

만약 ==를 사용하고 싶다면 switch문에 꼼수를 좀 부려야 한다.

```js
var a = 42;

switch (true) {
  case a == 10:
    console.log("10또는 '10' ");
    break;
  case a == 42:
    console.log("42또는 '42' ");
    break;
  default:
  // 여기 올 일은 없다.
}
// 42 또는 '42'
```

switch 표현식의 결과(true)와 case 표현식의 결과를 엄격하게 매치해보면, a == 42는 true이므로 매치되어 실행된다.
그러나 case 표현식 평가 결과가 truthy이지만 엄격히 true는 아닐 경우 매치는 실패한다. 이를테면 표현식에 &&나 ||같은 '논리 연산자'를 사용할 때 문제가 된다.

```js
var a = "Hello Word";
var b = 10;

switch (true) {
  case a || b == 10:
    console.log("10또는 '10' ");
    break;
  default:
    console.log("어이쿠");
}
// 어이쿠
```

(a || b == 10)평과 결과는 true가 아닌 "Hello World"이므로 매치가 되지 않는다. 이 떄는 분명히 표현식의 결과가 true/false로 떨어지게 `case !!(a || b == 10)`과 같이 작성해야 한다.

switch 문에서 default 절은 선택사항이다. 꼭 끝 부분에 슬 필요는 없지만, default에서 break를 안 써주면 그 이후로 코드가 계속 실행된다.

## 정리

- 표현식은 순수하고 독립적이지만 부수 효과를 일으킬 수 있다.
- { }는 쌓은 문 블록, 객체 리터럴, 객체 할당, 명명된 함수 인자로 쓸 수 있다.
- 자바스크립트 에러는 몇 가지 유행이 있지만 크게 조기 에러(컴파일러가 던진 잡을 수 없는 에러)와 런타임 에러(try catch로 잡을 수 있는 에러)로 분류된다.

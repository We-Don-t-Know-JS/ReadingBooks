# 네이티브

> 네이티브(Native)란 특정 환경(브라우저 등 클라이언트 프로그램)에 종속되지 않은 ECMAScript 명세의 내장 객체를 말함. 예를 들어 Object, Math, Function, Array, Window, Button 중에서 Window, Button은 네이티브가 아니다.

가장 많이 쓰는 네이티브

- String()
- Number()
- Boolean()
- Array()
- Object()
- Function()
- RegExp()
- Date()
- Error()
- Symbol()

네이티브는 내장 함수다.

네이티브는 생성자처럼 사용할 수 있다. 그러나 실제로 생성되는 결과물은 예상과 다를 수 있다.

```js
var a = new String("abc");
typeof a; // "object"
a instanceof String; // true
Object.prototype.toString.call(a); // "[object String]"
```

new String("abc") 생성자의 결과값은 원시값 "abc"를 감싼 객체 래퍼를 생성한다. 원시값 "abc"를 생성하는게 아니라는 점이다.

## 내부 [[Class]]

typeof가 object인 값(배열 등)에는 [[Class]]라는 내부 프로퍼티가 추가로 붙는다. 이는 전통적인 클래스 지향 개념에서의 클래스라기 보단 내부적 분류의 일부라고 보자. 이 프로퍼티는 직접 접근할 수 없고 Object.prototype.toString()라는 메서드에 값을 넣어 호출함으로써 존재를 엿볼 수 있다.

```js
Object.prototype.toString.call([1, 2, 3]); // "[object Array]"
```

내부 [[Class]] 값이 Array임을 알 수 있다. 대부분 내부 [[Class]]는 해당 값과 관련된 내장 넹니티브 생성자를 가리키지만, 그렇지 않을 때도 있다.
원시 값 중 null, undefined와 값도 [[Class]]와 같은 값을 가진다. 그 밖의 문자열, 숫자, 불리언 같은 단순 원시값은 박싱 과정을 거친다.

## 래퍼 박싱하기

원시 값엔 프로퍼티나 메서드가 없으므로 `.length`, `.toString()`으로 접근하려면 원시 값을 객체 래퍼로 감싸줘야 한다. 자바스크립트는 원시 값을 알아서 박싱(래핑)한다.
원시값을 직접 객체 형태로 써야할 이유는 거의 없다. 오히려 권하지 않는다. 필요시 엔진이 알아서 암시적으로 박싱하게 하는 것이 낫다. 즉, `new String("abc")` `.new Number(42)`처럼 코딩하지 말고 그냥 알기 쉽게 원시값을 사용하자.
수동으로 원시 값을 박싱하려면 new 키워드를 사용하지 않는 `Object()`를 사용하도록 한다.

## 언박싱

객체 래퍼의 원시 값은 `valueOf()` 메서드로 추출한다. 이때에도 암시적인 언박싱이 일어난다.

## 네이티브, 나는 생성자다

합성 값은 리터럴 형태로 생성하는 것이 일반적이지만, 리터럴은 생성자 형식으로 만든 것과 동일한 종류의 객체를 생성한다. 즉 래핑되지 않는 값은 없다.
생성자는 확실히 필요해서 쓰는 게 아닌 이상 가급적 사용하지 않는 편이 좋다.

### Array()

Array 생성자에는 특별한 형식이 하나 있다. 인자로 숫자를 하나만 받으면 그 숫자를 원소로 하는 배열을 생성하는게 아니라 배열의 크기를 미리 정하는 기능이다.
그러나 배열의 크기를 미리 정한다는 것 자체가 말이 안된다. 그렇게 하려면 빈 배열을 만들고 나중에 length 프로퍼티에 숫자 값을 할당하는게 맞다.

```js
var a = new Array(3);

a.length; // 3, undefined x 3 == 빈 슬롯 3개
```

빈 슬롯은 배열 생성 직후 만들어진다. 실제로 정의된 슬롯 개수를 초과해 length 값을 세팅하면 암시적으로 빈 슬롯이 생긴다.
빈 슬롯 말고 진짜 undefined 값 원소로 채워진 배열은 손수 입력하지 않고 어떻게 생성할까?

```js
var a = Array.apply(null, { length: 3 ;})
a; // [undefined, undefined, undefined]
```

하지만 이런 이국적인 빈 슬롯 배열을 애써서 만들진 말도록 한다. 바보같다!

### Object(), Function(), RegExp()

Object(), Function(), RegExp() 생성자도 선택사항이다. 하지만 어떤 분명한 의도가 아니라면 굳이 사용하지 말도록 하자.

- new Object()
  리터럴 형태로 여러 프로퍼티를 쓸 수 있는게 굳이 비효율적으로 쓸 이유가 x
- new Function()
  함수의 인자나 내용을 동적으로 정의해야 하는 매우 드문 경우에 한해 유용
- 정규 표현식
  정규 표현식은 리터럴 형식으로 정의할 것을 적극 권장한다. 리터럴 형식이 구문이 쉽고 무엇보다 성능상 이점 (js 엔진이 실행 전 정규표현식을 미리 컴파일 한 후 캐시함)이 있다. RegExp()는 정규 표현식 패턴을 동적으로 사용할 경우 의미있는 유틸리티다.

### Date() and Error()

네이티브 생성자 Date()와 Error()는 리터럴 형식이 없으므로 다른 네이티브에 비해 유용하다.

- Date()
  `new Date()`로 date 객체 값을 생성한다. 이 생성자는 날짜/시각을 인자로 받는다. 인자를 생략하면 현재 날짜/시각으로 대신한다. ES5에 정의된 정적 도우미 함수 `Date.now()`를 사용하는게 더욱 쉽다.
  new 키워드 없이 `Date()`를 호출하면 현재 날짜/시각에 해당하는 문자열을 반환한다.
- Error()
  앞에 new의여부에 관계없이 결과는 같다.
  error 객체의 주 용도는 현재 실행 콘텍스트를 포착해 객체에 담는 것이다. 이 실행 스택 콘텍스트는 디버깅에 도움이 될 만한 정보를 담고 있다.

### Symbol()

ES6에 처음 선보인 새로운 원시 값이다. 심벌은 객체가 아닌 단순한 원시 값이다.
심벌은 충돌 염려 없이 객체의 프로퍼티로 사용 가능한, 특별한 유일한 값이다. 단, 절대적으로 유일함이 보장되지는 않는다. 주로 ES6의 특수한 내장 로직에 쓰기 위해 고안되었다.
심벌은 프로퍼티명으로 사용할 수 있으나, 프로그램 코드나 개발자 콘솔 창에서 실제 값을 보거나 접근할 수는 없다. 심벌 값을 콘소랓엥 출력해보면 Symbol(Symbol.create)로 나온다.

심벌을 직접 정의하려면 Symbol() 네이티브를 사용한다. 심벌은 new 키워드를 앞에 붙이면 에러가 나는 유일한 네이티브 생성자다.
심벌은 개발자가 전용/특수/내부 프로퍼티임을 표현하고 싶을 때 쓰는 언더스코어 대신 대체해 사용할 수 있다.

### 네이티브 프로토타입

내장 네이티브 생성자는 각자의 .prototype 객체를 가진다. prototype 객체에는 해당 객체의 하위 타입별로 고유한 로직이 담겨 있다.
프로토타입 위임 덕분에 하위 타입들이 상위 타입의 메서드를 같이 쓸 수 있다.

프로토타입으로 디폴트 값을 세팅할 수 있다. 하지만 해당 값을 호출할때 마다 디폴트 값을 다시 생성-(후 가비지 콜렉팅) 하므로 그만큼 메모리/CPU가 낭비된다. 어떤 식으로도 프로토타입을 변경하지 않도록 유의하도록 하자.

## 정리

1. 자바스크립트는 원시 값을 감싸는 객체 래퍼, 즉 네이티브를 제공한다.
2. 그러나 래퍼 박싱은 잘 사용할 일이 없다. 어지간한 경우에는 리터럴을 쓰도록 한다.
3. 심벌은 특별한 유니크한 값을 표현할 때 쓴다. 객체가 아닌 단순한 원시값이다. 네이티브 생성자이지만 new 키워드를 붙여 선언하면 에러가 난다.
4. 단순 스칼라 원시 값이 있을 때, 이 값의 prototype에 정의된 메서드를 호출하면 자바스크립트는 자동으로 원시 값을 박싱(해당되는 객체 래퍼로 박싱)해 필요한 프로퍼티와 메서드를 쓸 수 있게 도와준다.

# 강제변환

## 값 변환

어떤ㄷ 값을 다른 타입의 값으로 바꾸는 과정이

- 명시적: `타입 캐스팅` 이라고 부름.
  코드만 봐도 의도적으로 타입변환을 일으킨다는 사실이 명백함.
- 암시적: `강제변환` 이라고 부름.
  불분명한 부수 효과로부터 발생하는 타입변환.

자바스크립트에서 강제변환을 하면 원시 값 중 하나가 되며 합성 값 타입으로 변환될 일은 없다. 또한 '박싱'은 원시 값을 해당 객체로 감싸는 것 뿐, 강제변환이 아니다.

## 추상연산

### ToString

**문자열이 아닌 값 => 문자열**

내장 원시 값은 본연의 문자열화 방법이 정해져 있음. (null => "null", undefined => "undefined")
숫자는 그냥 문자열로 바뀌고, 너무 작거나 큰 값은 지수 형태로 바뀐다. 일반 객체는 특별히 지정하지 않으면 `toString()`메서드가 내부 [[Class]]를 반환한다. (예: "[object Object]")
배열은 문자열 변환 시 모든 원소 값이 각각 문자열로 바뀌어 콤마로 분리된 형태로 이뤄진다.

자신의 toString()메서드를 가진 객체는 문자열처럼 사용하면 자동으로 이 메서드가 기본 호출되어 toString()을 대체한다.

### JSON

JSON 안전 값(안전값이 아닌 것들, 예: undefined, 함수, 시벌 등)은 모두 JSON.stringify()로 문자열화 할 수 있다. 안전 값이 아닌 값들이 배열에 포함되어 있으면 배열 인덱스 정보가 뒤바끼지 않도록 null로 바꾼다. 객체 프로퍼티에 있으면 지워버린다. 

부적잘한 값이나 직렬화하기 곤란한 객체 값을 문자열로 바꾸려면 `toJSON()`메서드를 따로 정의해야 한다. 그러나 `toJSON()`이 JSON 문자열 표현형을 반환하리라 넘겨짚는건 흔한 오해다. `toJSON()`은 적절한 평범한 실제 값을 반환하고 문자열화 처리는 `JSON.stringfy()`가 담당한다. 

다시 말해 `toJSON()`의 역할은 `문자열하기 적당한 JSON 안전 값`으로 바꾸는 것이다. json 문자열로 바꾸는 게 아니다.

1. 문자열, 숫자, 불리언, null값이 JSON으로 문자열화 하는 방식은 ToString 추상 연산의 규칙에 따라 문자열 값으로 강제 변환되는 방식과 동일하다.
2. JSON.stringify()에 전달한 객체가 자체 toJSON() 메서드를 갖고 있다면, 문자열화 전 toJSON()이 자동으로 호출되어 JSON 안전 값으로 강제변환 된다.

### ToNumber

**숫자 아닌 값 => 수식 연산이 가능한 숫자**

예: true=>1, false=>0, undefined=>NaN, null=>0

객체(그리고 배열)는 일단 동등한 원시 값으로 변환 후 그 결괏값(아직 숫자가 아닌 원시 값)을 ToNumber 규칙에 의해 강제변환 된다.
`valueOf()`를 쓸 수 있고 반환 값이 원시값이면 그대로 강제변환하되, 그렇지 않을 경우 `toString()` 메서드가 존재하면 이를 이용해 강제변환한다. 어찌해도 원시 값으로 바꿀 수 없을 땐 TypeError 오류를 던진다. ES5부터는 [[Prototype]]이 null인 경우 대부분 Object.create(null)을 이용해 강제변환이 불가능한 객체를 생성할 수 있다.

### ToBoolean

흔히 1이 true, 0이 false에 해당한다고 생각하는데 자바스크립트에서는 숫자는 숫자고, 불리언은 불리언으로 별개의 값이다. 이를 강제변환 할 수는 있지만, 두 값이 같지는 않다.

**Falsy값**

자바스크립트의 모든 값은 다음 중 하나다.

1. 불리언으로 강제변환하면 false가 되는 값
2. 1번을 제외한 나머지, 즉 명백한 true값

명세가 정의한 'falsy'값은 다음과 같다. 

- undefined
- null
- false
- +0, -0. NaN
- ""

이 값은 불리언으로 강제변환 하면 false다. 이외의 값은 truthy하다. 

**Truthy값**

""을 제외한 문자열 값 자체는 모두 truthy값이다. "undefined", "false" 또한 truthy한 값이다.

## 명시적 강제변환

분명하고 확실한 타입 변환

### 문자열 <>=> 숫자

`String()`과 `Number()`함수를 이용한다. 앞에 new키워드가 붙지 않기 때문에 객체 래퍼를 생성하는 것이 아니다. 두 함수 다 값을 받아 원시 값으로 변환한다. 
`String()`외에도 `toString()`을 사용해 문자열로 값을 바꿀 수 있다. `toString()`메서드는 원시값이 숫자인 값에서, 해당 메서드를 찾을 수 없으므로 `toString()`을 사용할 수 있게 자동으로 숫자 원시 값을 객체 래퍼로 박싱한다. 이는 명시적으로, 암시적인 작동이다.

`+` 단항 연산자를 사용해 문자열을 숫자로 바꿀 수도 있다. 피연산자를 숫자로, 명시적으로 강제변환한다.

### 날짜 => 숫자

`+` 단항 연산자는 Date 객체 => 숫자 강제변환 용도로도 쓰인다.(예: `+new Date()`) 하지만 ES5이후 추가된 정적 함수 `Date.now()`를 사용하는게 더욱 깔끔하다.

### 틸드 (~)

`~`연산자를 적용하면 전혀 다른 숫자 값을 강제변환 하는 효과가 있다. 틸드 연산자는 먼저 32비트 숫자로 **강제변환**한 후 NOT연산을 한다. (각 비트를 거꾸로 뒤집는다.) 이는 !이 불리언 값으로 강제변환 하는 것뿐만 아니라 비트를 거꾸로 뒤집는 것과 아주 비슷하다.

`~x`는 대략 `-(x+1)`과 같다. 일정 범위 내의 숫자 값에 ~ 연산을 할 경우 입력 값이 false로 쉽게 변환할 수 있는 값이면 falsy한 0, 그 외면 truthy한 숫자 값이 나타난다.

틸드 연산자의 사용 방법은 경계값을 사용할 때 쓰기 좋다. 경계값이란 개발자가 임의로 의미를 부여한 값이다. 예를 들어 `0`은 성공, `-1`은 실패 라는 의미를 부여할 때 틸드를 쓰기 좋다. `indexOf()`에 ~를 붙이면 어떤 값을 강제변환 해 불리언 값으로 적절하게 만들 수 있다. 직접 경계값을 부여하는 것보다 명시적이고 코드가 깔끔해질 수 있다.

틸드는 비트를 잘라낼 때 사용할 수도 있다. 더블 틸드(`~~`)는 소수점 이상 부분을 잘라내기 위해 사용할 수도 있다. 그러나 이 결과가 `Math.floor()`의 값과 같은 결과가 나오진 않다.
더블 틸드에서 맨 앞의 ~는 ToInt32 강제변환을 적용한 후 각 비트를 거꾸로 한다. 그리고 두 번째 ~는 비트를 또 한번 거꾸로 뒤지어, 결과적으로 원래 상태로 되돌린다. 

### 숫자 형태의 문자열 파싱

문자열에 `parseInt()`를 쓰면 숫자로 바꿀 수 있다. 단, 이 함수를 쓸 때는 인자가 문자열이 아닌 값은 집어넣을 필요가 없다. 인자가 비 문자열이면 제일 먼저 자동으로 문자열로 강제변환한다. 이는 일종의 감춰진 암시적 강제변환으로 바람직하지 않은 로직이다.

### 불리언

```js
var a = 42;
a ? true : false;
```

여기엔 암시적 강제변환이 매복해 있다. a를 일단 불리언으로 강제변환 해야 표현식의 true/false 여부를 따져볼 수 있기 때문이다.

## 암시적 변환

부수 효과가 명확하지 않게 숨겨진 형태로 일어나는 타입변환
즉, 분명하지 않은 타입 변환

암시적 타입 변환은 무조건적으로 나쁘지 않다.

암시적 타입 변환을 사용함으로써 코드의 중간 변환 단계, 불필요한 잡음(단계)를 줄이고 타입변환을 단순화 할 수 있다. 암시적 타입 변환을 사용함으로써 지저분한 코드를 단순화 할 수 있다. 

### 문자열 <=> 숫자

+ 연산자는 숫자의 덧셈, 문자열 접합 두 가지 목적으로 오버로드(일반 연산을 위한 연산자가 다른 기능을 하도록 구현하는 것)된다. 만약 `"42"+"0"`은 420이 나오고, `42+0`은 42로 결괏값이 나타날 때 자바스크립트 엔진은 어떻게 값을 결정할까?

+ 알고리즘(피연산자가 객체 값일 경우)은 한쪽 피연산자가 문자열이거나 다음 과정을 통해 문자열 표현형으로 나타낼 수 있으면 문자열 붙이기를 한다. 따라서 피연ㅅ나자중 하나가 객체(배열 포함)이라면, 먼저 이 값에 ToPrimitive 추상 연산을 수행하고, 다시 이 연산에 number 콘텍스트 힌트를 넘겨 [[DefaultValue]]알고리즘을 호출한다.

`valueOf()`에 배열을 넘기면 단순 원시 값을 반환할 수 없으므로 바통은 `toString()`으로 넘어간다. 

자바스크립트 프로그램에서는 문자열을 변환할 때 `b=String(a)`(명시적)과 `b = a+""`(암시적) 후자를 더욱 많이 쓴다. 암시적 변환이 무조건적으로 나쁜 방법은 아니다. 

### 불리언 <=> 숫자

암시적 강제변환의 효용성은 복잡한 형태의 불리언 로직을 단순한 숫자 덧셈 형태로 단순화할때 빛을 바란다. 예를 들어 한 함수가 있고 세가지 인자를 받을 때, 정확히 하나만 true/truthy를 확인한다. 만약 인자의 값이 여러개가 있을 때, 모든 비교 로직을 수행한다는건 상당히 까다롭다. 이때 불리언 값을 숫자(명시적으로 0 또는 1)로 변환하면 쉽게 해결할 수 있다.

### * => 불리언

가장 평범하면서도 가장 골칫거리다.
다음은 불리언의로의 암시적인 강제변환이 일어나는 표현식의 종류다.

1. if()문의 조건식
2. for ( ; ; ) 에서 두 번째 조건 표현식
3. while() 및 do...while()루프의 조건 표현식
4. ? : 삼항 연산 시 첫 번째 조건 표현식
5. || 및 && 의 좌측 피연산자

이런 콘텍스트에서 불리언이 아닌 값이 사용되면, ToBoolean 추상 연산 규칙에 따라 일단 불리언 값으로 암시적 강제변환 된다. 비 불리언 값은 조건 표현식을 평가하기 위해 그와 동등한 불리언 값으로 강제변환 된다.
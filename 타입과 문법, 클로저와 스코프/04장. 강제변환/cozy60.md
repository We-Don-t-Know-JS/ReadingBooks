# 강제변환

## 값 변환

어떤 값을 다른 타입의 값으로 바꾸는 과정이

- 명시적: `타입 캐스팅` 이라고 부름.
  코드만 봐도 의도적으로 타입변환을 일으킨다는 사실이 명백함.
- 암시적: `강제변환` 이라고 부름.
  불분명한 부수 효과로부터 발생하는 타입변환.

자바스크립트에서 강제변환을 하면 원시 값 중 하나가 되며 합성 값 타입으로 변환될 일은 없다. 또한 '박싱'은 원시 값을 해당 객체로 감싸는 것 뿐, 강제변환이 아니다.

## 추상연산

### ToString

**문자열이 아닌 값 => 문자열**

내장 원시 값은 본연의 문자열화 방법이 정해져 있음. (null => "null", undefined => "undefined")
숫자는 그냥 문자열로 바뀌고, 너무 작거나 큰 값은 지수 형태로 바뀐다. 일반 객체는 특별히 지정하지 않으면 `toString()`메서드가 내부 [[Class]]를 반환한다. (예: "[object Object]")
배열은 문자열 변환 시 모든 원소 값이 각각 문자열로 바뀌어 콤마로 분리된 형태로 이뤄진다.

자신의 toString()메서드를 가진 객체는 문자열처럼 사용하면 자동으로 이 메서드가 기본 호출되어 toString()을 대체한다.

### JSON

JSON 안전 값(안전값이 아닌 것들, 예: undefined, 함수, 시벌 등)은 모두 JSON.stringify()로 문자열화 할 수 있다. 안전 값이 아닌 값들이 배열에 포함되어 있으면 배열 인덱스 정보가 뒤바끼지 않도록 null로 바꾼다. 객체 프로퍼티에 있으면 지워버린다.

부적잘한 값이나 직렬화하기 곤란한 객체 값을 문자열로 바꾸려면 `toJSON()`메서드를 따로 정의해야 한다. 그러나 `toJSON()`이 JSON 문자열 표현형을 반환하리라 넘겨짚는건 흔한 오해다. `toJSON()`은 적절한 평범한 실제 값을 반환하고 문자열화 처리는 `JSON.stringfy()`가 담당한다.

다시 말해 `toJSON()`의 역할은 `문자열하기 적당한 JSON 안전 값`으로 바꾸는 것이다. json 문자열로 바꾸는 게 아니다.

1. 문자열, 숫자, 불리언, null값이 JSON으로 문자열화 하는 방식은 ToString 추상 연산의 규칙에 따라 문자열 값으로 강제 변환되는 방식과 동일하다.
2. JSON.stringify()에 전달한 객체가 자체 toJSON() 메서드를 갖고 있다면, 문자열화 전 toJSON()이 자동으로 호출되어 JSON 안전 값으로 강제변환 된다.

### ToNumber

**숫자 아닌 값 => 수식 연산이 가능한 숫자**

예: true=>1, false=>0, undefined=>NaN, null=>0

객체(그리고 배열)는 일단 동등한 원시 값으로 변환 후 그 결괏값(아직 숫자가 아닌 원시 값)을 ToNumber 규칙에 의해 강제변환 된다.
`valueOf()`를 쓸 수 있고 반환 값이 원시값이면 그대로 강제변환하되, 그렇지 않을 경우 `toString()` 메서드가 존재하면 이를 이용해 강제변환한다. 어찌해도 원시 값으로 바꿀 수 없을 땐 TypeError 오류를 던진다. ES5부터는 [[Prototype]]이 null인 경우 대부분 Object.create(null)을 이용해 강제변환이 불가능한 객체를 생성할 수 있다.

### ToBoolean

흔히 1이 true, 0이 false에 해당한다고 생각하는데 자바스크립트에서는 숫자는 숫자고, 불리언은 불리언으로 별개의 값이다. 이를 강제변환 할 수는 있지만, 두 값이 같지는 않다.

**Falsy값**

자바스크립트의 모든 값은 다음 중 하나다.

1. 불리언으로 강제변환하면 false가 되는 값
2. 1번을 제외한 나머지, 즉 명백한 true값

명세가 정의한 'falsy'값은 다음과 같다.

- undefined
- null
- false
- +0, -0. NaN
- ""

이 값은 불리언으로 강제변환 하면 false다. 이외의 값은 truthy하다.

**Truthy값**

""을 제외한 문자열 값 자체는 모두 truthy값이다. "undefined", "false" 또한 truthy한 값이다.

## 명시적 강제변환

분명하고 확실한 타입 변환

### 문자열 <>=> 숫자

`String()`과 `Number()`함수를 이용한다. 앞에 new키워드가 붙지 않기 때문에 객체 래퍼를 생성하는 것이 아니다. 두 함수 다 값을 받아 원시 값으로 변환한다.
`String()`외에도 `toString()`을 사용해 문자열로 값을 바꿀 수 있다. `toString()`메서드는 원시값이 숫자인 값에서, 해당 메서드를 찾을 수 없으므로 `toString()`을 사용할 수 있게 자동으로 숫자 원시 값을 객체 래퍼로 박싱한다. 이는 명시적으로, 암시적인 작동이다.

`+` 단항 연산자를 사용해 문자열을 숫자로 바꿀 수도 있다. 피연산자를 숫자로, 명시적으로 강제변환한다.

### 날짜 => 숫자

`+` 단항 연산자는 Date 객체 => 숫자 강제변환 용도로도 쓰인다.(예: `+new Date()`) 하지만 ES5이후 추가된 정적 함수 `Date.now()`를 사용하는게 더욱 깔끔하다.

### 틸드 (~)

`~`연산자를 적용하면 전혀 다른 숫자 값을 강제변환 하는 효과가 있다. 틸드 연산자는 먼저 32비트 숫자로 **강제변환**한 후 NOT연산을 한다. (각 비트를 거꾸로 뒤집는다.) 이는 !이 불리언 값으로 강제변환 하는 것뿐만 아니라 비트를 거꾸로 뒤집는 것과 아주 비슷하다.

`~x`는 대략 `-(x+1)`과 같다. 일정 범위 내의 숫자 값에 ~ 연산을 할 경우 입력 값이 false로 쉽게 변환할 수 있는 값이면 falsy한 0, 그 외면 truthy한 숫자 값이 나타난다.

틸드 연산자의 사용 방법은 경계값을 사용할 때 쓰기 좋다. 경계값이란 개발자가 임의로 의미를 부여한 값이다. 예를 들어 `0`은 성공, `-1`은 실패 라는 의미를 부여할 때 틸드를 쓰기 좋다. `indexOf()`에 ~를 붙이면 어떤 값을 강제변환 해 불리언 값으로 적절하게 만들 수 있다. 직접 경계값을 부여하는 것보다 명시적이고 코드가 깔끔해질 수 있다.

틸드는 비트를 잘라낼 때 사용할 수도 있다. 더블 틸드(`~~`)는 소수점 이상 부분을 잘라내기 위해 사용할 수도 있다. 그러나 이 결과가 `Math.floor()`의 값과 같은 결과가 나오진 않다.
더블 틸드에서 맨 앞의 ~는 ToInt32 강제변환을 적용한 후 각 비트를 거꾸로 한다. 그리고 두 번째 ~는 비트를 또 한번 거꾸로 뒤지어, 결과적으로 원래 상태로 되돌린다.

### 숫자 형태의 문자열 파싱

문자열에 `parseInt()`를 쓰면 숫자로 바꿀 수 있다. 단, 이 함수를 쓸 때는 인자가 문자열이 아닌 값은 집어넣을 필요가 없다. 인자가 비 문자열이면 제일 먼저 자동으로 문자열로 강제변환한다. 이는 일종의 감춰진 암시적 강제변환으로 바람직하지 않은 로직이다.

### 불리언

```js
var a = 42;
a ? true : false;
```

여기엔 암시적 강제변환이 매복해 있다. a를 일단 불리언으로 강제변환 해야 표현식의 true/false 여부를 따져볼 수 있기 때문이다.

## 암시적 변환

부수 효과가 명확하지 않게 숨겨진 형태로 일어나는 타입변환
즉, 분명하지 않은 타입 변환

암시적 타입 변환은 무조건적으로 나쁘지 않다.

암시적 타입 변환을 사용함으로써 코드의 중간 변환 단계, 불필요한 잡음(단계)를 줄이고 타입변환을 단순화 할 수 있다. 암시적 타입 변환을 사용함으로써 지저분한 코드를 단순화 할 수 있다.

### 문자열 <=> 숫자

- 연산자는 숫자의 덧셈, 문자열 접합 두 가지 목적으로 오버로드(일반 연산을 위한 연산자가 다른 기능을 하도록 구현하는 것)된다. 만약 `"42"+"0"`은 420이 나오고, `42+0`은 42로 결괏값이 나타날 때 자바스크립트 엔진은 어떻게 값을 결정할까?

- 알고리즘(피연산자가 객체 값일 경우)은 한쪽 피연산자가 문자열이거나 다음 과정을 통해 문자열 표현형으로 나타낼 수 있으면 문자열 붙이기를 한다. 따라서 피연ㅅ나자중 하나가 객체(배열 포함)이라면, 먼저 이 값에 ToPrimitive 추상 연산을 수행하고, 다시 이 연산에 number 콘텍스트 힌트를 넘겨 [[DefaultValue]]알고리즘을 호출한다.

`valueOf()`에 배열을 넘기면 단순 원시 값을 반환할 수 없으므로 바통은 `toString()`으로 넘어간다.

자바스크립트 프로그램에서는 문자열을 변환할 때 `b=String(a)`(명시적)과 `b = a+""`(암시적) 후자를 더욱 많이 쓴다. 암시적 변환이 무조건적으로 나쁜 방법은 아니다.

### 불리언 <=> 숫자

암시적 강제변환의 효용성은 복잡한 형태의 불리언 로직을 단순한 숫자 덧셈 형태로 단순화할때 빛을 바란다. 예를 들어 한 함수가 있고 세가지 인자를 받을 때, 정확히 하나만 true/truthy를 확인한다. 만약 인자의 값이 여러개가 있을 때, 모든 비교 로직을 수행한다는건 상당히 까다롭다. 이때 불리언 값을 숫자(명시적으로 0 또는 1)로 변환하면 쉽게 해결할 수 있다.

### \* => 불리언

가장 평범하면서도 가장 골칫거리다.
다음은 불리언의로의 암시적인 강제변환이 일어나는 표현식의 종류다.

1. if()문의 조건식
2. for ( ; ; ) 에서 두 번째 조건 표현식
3. while() 및 do...while()루프의 조건 표현식
4. ? : 삼항 연산 시 첫 번째 조건 표현식
5. || 및 && 의 좌측 피연산자

이런 콘텍스트에서 불리언이 아닌 값이 사용되면, ToBoolean 추상 연산 규칙에 따라 일단 불리언 값으로 암시적 강제변환 된다. 비 불리언 값은 조건 표현식을 평가하기 위해 그와 동등한 불리언 값으로 강제변환 된다.

## 연산자

### && 와 ||

두 연산자의 의미는 선택 연산자 or 피연산자 선택 연산자라고 부르는게 더 적합할 수 있다.
이는 실제로 결괏값이 논리 값(불리언)이 아니기 때문이다. 결괏값은 두 피연산자 중 한쪽 (오직 한쪽의) 값이다. 둘 중 하나의 값을 선택한다.

ES5 명세중

> && 또는 || 연산자의 결괏값이 반드시 불리언 타입이어야 하는 것은 아니며 항상 두 피연산자 표현식 중 어느 한쪽 값으로 귀결된다.

**|| 연산자**
결과가 true면 첫 번째 피연산자 값을, false면 두 번째 피연산자 값을 반환한다.

**&& 연산자**
결과가 true면 두 번째 피연산자의 값을, false면 첫 번째 피연산자의 값을 반환한다.

두 표현식의 결괏값은 언제나 피연산자의 값 중 하나이고, 평가 결과가 아니다.

어렵다면 다음과 같이 생각하자.

```js
a || b;
// 이는 대략 다음과 같음
a ? a : b;

a && b;
// 이는 대략 다음과 같음
a ? b : a;
```

대략 같다고 표현했지만 의미상 차이는 있다. 만약 `a ? a : b`의 a가 복잡한 표현식(함수 호출등의 부수효과를 가진 표현식)이라면, a 표현식은 두번 평과 될 가능성이 있다. 반면 `a || b` 에서 a는 단 한번만 평ㄴ가하고 그 결과는 테스트 수행 시 강제변환과 최종 결괏값 양쪽 모두 사용된다.

이러한 특성을 잘 살린 코드를 살펴보자.

```js
function foo(a, b) {
  a = a || "hello";
  b = b || "world";

  console.log(a + "" + b);
}
```

```js
foo("바로 이거야!", ""); // "바로 이거야! world"
```

두번째 인자값 `""` falsy 값이기 때문에 디폴트 값인 후자의 값이 리턴된다.
`||`연산자의 이러한 사용 패턴은 매우 흔하고 제법 쓸 만하지만 falsy 값은 무조건 건너뛸 경우에만 사용해야 한다. 그렇지 않으면 조건 평가식을 삼항 연산자로 더욱 명시적으로 정해야 한다.

&& 연산자는 첫 번째 피연산자의 평과 결과가 truthy일 때에만 두 분째 연산자를 '선택'한다고 헀는데 이런 특성을 **가드 연선자** 라고 한다. 첫 번째 표현식이 두 번째 표현식의 '가드'역할을 하는 것이다.

복합 표현식이 평가된 다음 불리언으로 암시적 강제변환이 일어난다. 이러한 코드는 암시적 강제변환을 사용한다.

## 심벌의 강제변환

심벌 값은 절대 숫자로 변환되지 않는다. (예: `"Symbol(4)"`)
희한하게도 불리언 값으로는 명ㅅ시적/암시적 모두 강제변환이 가능하다. 그렇지만 심벌은 강제변환할 일이 정말 드물다.

## 느슨한/엄격한 동등 비교

느슨한 동등 비교는 `==`연산자를, 엄격한 동등 비교는 `===`연산자를 각각 사용한다. 두 연산자 모두 값의 동등함을 비교허지만 '느슨함'과 '엄격함'이라는 아주 중요한 차이점이 있고 특히 '동등함'의 판단 기준이 다르다.

`==`는 값의 동등함을, `===`는 값과 타입 모두의 동등함을 비교한다고 오해한다. 그렇지만 이는 정확하지 않다.

> 동등함의 비교 시 `==`는 강제변환을 허용하지만, `===`는 강제변환을 허용하지 않는다.

### 비교 성능

`===`는 타입까지 체크하므로 할 일이 많으므로, 눈에 띄게 처리가 더뎌진다고 생각할 수 있다. 하지만 불과 몇 마이크로초 단위의 차이일 뿐이다.
타입이 같은 두 값의 동등 비교라면, ==와 ===의 알고리즘은 동일하다.

강제변환이 필요하다면 느슨한 동등 연산자(==)를, 필요하지 않다면 엄격한 동등 연산자 (===)를 사용하자.

### 추상 동등 비교

- NaN은 그 자신과도 결코 동등하지 않다.
- +0과 -0는 동등하지 않다.

**객체**

느슨한 동등 비교에 대해 두 객체가 정확히 똑같은 값에 대한 레퍼런스일 경우에만 동등하다고 기술되어 있다. 여기서 강제변환은 일어나지 않는다.
객체의 동등 비교에 있어서 ==와 ===의 로직은 동일하다.

!=의 결괏값은 == 연산자의 동등 비교 수행 후 그 결과를 그대로 부정한 값이다. 엄격한 비동등 연산자(!==)역시 마찬가지다.

**문자열 => 숫자**

느슨한 동등 비교는 피연산자의 타입이 다르면, 비교 알고리즘에 의해 한쪽 또는 양쪽 피연산자 값이 알아서 암시적으로 강제변환된다.
이는 정확히 어떻게 강제변환이 일어나는 걸까?

> 1. Type(x)가 Number고 Type(y)가 String이면, x == ToNumber(y) 비교 결과를 반환한다.
> 2. Type(x)가 String이고 Type(y)가 Number면, ToNumber(x) == y 비교 결과를 반환한다.

강제변환은 ToNumber 추상 연산이 담당한다.

**\* => 불리언**

어떤 값을 true/false와 직접 비교하려고 하면 강제변환의 끔찍한 함정에 빠지게 된다.

```js
var a = "42";
var b = true;

a == b;
```

"42"는 truthy 값이니 비교하면 true가 아닌가 싶지만, 반대인 이유는 단순하면서도 꽤 까다롭다.
ES5의 명세를 참고해보자.

> 1. Type(x)이 불리언이면 ToNumber(x) == y의 비교 결과를 반환한다.
> 2. Type(y)이 불리언이면 x == ToNumber(y)의 비교 결과를 반환한다.

위의 코드는 `1 == "42"`이 된다. 타입이 상이하므로 알고리즘을 수행해 `1 == 42`가 된다. 결과는 false가 된다.
순서가 바뀌어도 결과는 같다.

`"42" == 0 => 42 == 0 => false`

"42"가 불리언(true)로 강제변환되는 것이 아니라 true가 1로 강제변환되고 그 후 "42"가 42로 강제변환 된다. ToBoolean은 전혀 개입하지 않으며, "42"값 자체의 truthy/falsy 여부는 == 연산과는 전혀 무관하다.

**==의 피연산자 한쪽이 불리언 값이면 예외 없이 그 값이 먼저 숫자로 강제변환된다.**

== 연산자를 사용해 불리언 값으 비교하는건 비추천 한다. ===연산자는 강제변환을 허용하지 않기에 ToNumber 강제변환 따위는 신경쓰지 않아도 된다.

### null => undefined

null과 undefined간의 변환은 느슨한 동등 비교 ==이 암시적 강제변환을 하는 또 다른 예다.

> 1. x가 null이고 y가 undefined면 true를 반환한다.
> 2. x가 undefined면 y가 null이면 true를 반환한다.

null과 undefined를 느슨한 동등 비교하면 서로에게 타입을 맞춘다.(강제변환한다.)
즉, null과 undefined는 느슨한 동등 비교 시 상호간의 암시적인 강제변환이 일어나므로 비교 관점에서 구분되지 않는 값으로 취급되는 것이다.

이 강제변환은 안전하고 예측 가능하다.

### 객체 => 비객체

> 1. Type(x)가 String 또는 Number고 Type(y)가 객체라면, x == ToPrimitive(y)의 비교 결과를 반환한다.
> 2. Type(x)가 Object이고 Type(y)가 String 또는 Number라면, ToPrimitive(x) == y 의 비교 결과를 반환한다.

```js
var a = 42;
var b = [42];

a == b; //true
```

[ 42 ]는 ToPrimitive 추상 연산 결과, "42"가 된다. 그리고 "42" == 42 => 42 == 42 이므로 a,b는 동등하다.

원시 값을 감싼 객체 래퍼(예: new String("abc"))를 한 꺼풀 벗겨 원시값("abc")를 반환하는 과정이다. 언박싱은 == 알고리즘의 ToPrimitive 강제변환과 관련되어 있다.

```js
var a = "abc";
var b = Obejct(a); // new String(a)와 같다.

a === b; // false
a == b; // true
```

b는 ToPrimitive 연산으로 "abc"라는 단순 스칼라 원시 값으로 강제변환되고 이 값은 a와 동일하므로 a == b는 true가 맞다.

하지만 항상 그런 것은 아니다. == 알고리즘에서 더 우선하는 규칙 때문에 그렇지 않은 경우들도 있다.

```js
var a = null;
var b = Object(a); // Obejct()와 같다.
a == b; // false

var c = undefined;
var d = Object(c); // Object()와 같다.
c == d; // false

var e = NaN;
var f = Object(e); // new Number(e)와 같다.
e == f; // false
```

null과 undefined는 객체 래퍼가 따로 없으므로 박싱할 수 없다. 그래서 Object(null)은 Object()로 해석되어 그냥 일반 객체가 만들어진다.
NaN은 NUmber로 박싱되지만 ==를 만나 언박싱 되면 결국 NaN == NaN이 되어 false다.

### 희귀 사례

```js
"0" == false; // true
false == "0"; // true
false == ""; // true
false == []; // true
"" == 0; // true
"" == []; // true
0 == []; // true
```

### 암시적 강제변환의 안전한 사용법

- 피연산자 중 하나가 true/false일 가능성이 있으면 "절대로" == 연산자를 쓰지 말자.
- 피연산자 중 하나가 [], " ", 0이 될 가능성이 있으면 가급적 == 연산자는 쓰지 말자.

두 연산자중 한가지를 사용할지는. "동등 비교 시 강제변환을 허용할 거냐 말 거냐"와 본질적으로 같다.

## 추상 관계 비교

a < b 비교 과정에서 어떤 일이 벌어지는지 알아보자. 이 알고리즘은 비교 시 피연산자 모두 문자열일때와 그 외의 경우 두가지로 나뉜다.

이 알고리즘은 두 피연산자에 대해 ToPrimitive 강제변환을 실시하는 것으로 시작한다. 그 결과, 어느 한쪽이라도 문자열이 아닐 경우 양쪽 모두 ToNumber로 강제변환하여 숫자값으로 만들어 비교한다.

예를 들면,

```js
var a = [42];
var b = ["43"];

a < b; // true
b < a; // false
```

그러나 < 비교대상이 모두 문자열 값이면, 각 문자를 단순 어휘(즉 알파벳 숫자)로 비교한다.

객체를 보자.

```js
var a = { b: 42 };
var b = { b: 42 };

a < b; // false
```

a의 값은 [object Object], b또한 [object Object]로 변환되어 어휘적인 비교를 할 수 없기 때문이다.

### <= 연산자

```js
var a = { b: 42 };
var b = { b: 42 };

a <= b; // true
a >= b; // true
```

`a <= b`는 실제로 b < a 의 평과 결과를 부정하도록 명세에 기술되어있다.
그러므로, b < a가 false이므로 a <=b는 이를 부정한 true가 된다.

<=이 같거나 더 작은 부등호의 의미라고 당연시 생각할 수 있다. 실제로 자바스크립트 엔진은 <=를 더 크지 않은(`!(a > b)` => `!(b < a)`)의미로 해석한다. 더구나 a >= b는 먼저 b <= a 로 재해석한 다음 동일한 추론을 적용한다.

동등 비교에 관한 한 엄격한 관계 비교는 없다. 다시 말해, 비교 전 a와 b 모두 명시적으로 동일한 타입임을 확실히 하는 방법 말고는 a < b 같은 관계 비교 과정에서 암시적 강제 변환을 원천 봉쇄할 수는 없다. <를 사용하기 전 명시적으로 강제변환해두는 편이 안전하다.

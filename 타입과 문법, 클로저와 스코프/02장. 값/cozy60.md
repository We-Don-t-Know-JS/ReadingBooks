# 값

## 배열

자바스크립트의 배열은 어떤 타입이라도 담을 수 있다. 크기를 미리 선언하지 않고 원하는 값을 추가할 수 있다.
비어 있는 배열을 다룰 때는 조심해야 한다. 비어있는 슬롯의 값을 출력하면 `undefined`가 반환되지만, 명시적으로 `a[1]=undefined`를 세팅한 것과 같진 않다.

배열 인덱스는 숫자이지만, 배열 자체도 하나의 객체여서 키/프로퍼티 문자열을 추가할 수 있다.

```js
var a = [];

a[0] = 1;
a["foobar"] = 2;

console.log(a); // [1, foobar: 2]
console.log(a.foobar); // 2
```

하지만 배열에서 키/프로퍼티 문자열을 추가할 시 배열 length가 증가하지 않는다.

```js
console.log(a.length); // 1
```

그런데 키로 넣은 문자열 값이 표준 10진수 숫자로 타입이 바뀌면, 마치 문자열 키가 아닌 숫자 키를 사용한 것 같은 결과가 초래된다.

```js
var a = [];
a["13"] = 42;

console.log(a.length); // 14
console.log(a); // (14) [empty × 13, 42]
```

일반적으로 배열에 문자열 키/프로퍼티를 두는건 추천하지 않는다. 배열 원소의 인덱스는 확실히 숫자만 쓰도록 하자.

### 유사 배열

> 유사 배열은 배열과 유사한 객체를 말한다. 배열처럼 생겼지만, `Array.isArray` 메서드를 사용하면 값이 false로 반환된다.

예를 들어 DOM 쿼리 작업을 수행하면 유사배열 형태의 DOM 원소 리스트가 반환된다. (이들의 반환 형태는 nodeList이다.)
다른 형태로 함수에서 arguments 객체를 사용해 인자를 리스트로 가져오는 것 또한 마찬가지이다.

이러한 유사 배열을 진짜 배열로 바꾸고 싶을떄 `slice()`함수를 주로 사용한다.
`slice()`함수는 인자가 없으면 기본 인자 값으로 구성된 배열을 복사한다. `Array.protorype.slice.call(arguments)`는 `Array.protorype.slice.call(arguments, 0)`과 동일하다. 첫 번쨰 원소부터 끝까지 잘라내므로 배열을 복사하는 것이나 다름없다. ES6에서는 기본 내장 함수 `Array.from()`이 이 일을 대신한다.

> Array.from() 메서드는 유사 배열 객체나 반복 가능한 객체를 얕게 복사해 새로운 Array를 만들어낸다.

### 문자열

문자열 !== 문자 배열 <br />
문자열과 문자 배열은 겉모습이 닮았다. 둘 다 length 프로퍼티와 `indexOf()` 메서드, `cocant()` 메서드를 가진다.
문자열은 불변값이지만 배열은 가변값이다. 인덱스를 사용해(`a[1]`)처럼 접근하는 형태가 모든 자바스크립트 엔진에서 유효하진 않다. `a.charAt(1)`으로 접근해야 맞는 방식이다.
문자열은 불변 값이므로 문자열 메서드는 그 내용을 바로 변경하지 않고 항상 새로운 문자열을 생성한 후 반환한다. 반면 대부분의 배열 메서드는 그 자리에서 곧바로 원소를 수정한다.
문자열을 다룰 때 대부분의 배열 메서드는 사실상 문자열에 쓸 수 없지만, 문자열에 대해 불변 배열 메서드를 빌려 쓸 수는 있다.

문자열에 대해 작업을 빈번히 수행한다면 문자열은 문자 단위로 저장하는 배열로 취급하는게 더 나을 수 있다.

## 숫자

자바스크립트의 숫자 타입은 number가 유일하다. 정수와 부동 소수점 숫자 모두 number이다.
숫자 값은 Number 객체 래퍼로 박싱할 수 있기 떄문에 `Number.prototype`메서드로 접근할 수 있다.
큰 숫자는 지수형으로 표사한다, 숫자 리터럴은 2진, 8진, 16진 등 다른 진법으로도 나타낼 수 있다.

ES6부터 `Number.isInteger()`로 정수 여부를 확인할 수 있다.

```js
Number.isInteger(42); // true
Number.isInteger(42.3); // false
```

## 특수 값

### 값 아닌 값

undefined 타입의 값은 undefined밖에 없다. null 타입 또한 값은 null 뿐이다. 그래서 이 둘은 타입과 값이 항상 같다.

각기 다른 의미로 사용도 가능하다. (ex: `null`은 빈값, `undefined`는 실종된 값/`null`은 예전에 값이 있었지만 현재는 없는 상태, `undefined`는 값을 아직 가지지 않은 것)

null은 식별자가 아닌 특별한 키워드이므로 null이라는 변수에 뭔가를 할당할 수는 없다. 그러나 undefined는 식별자로 쓸 수 있다.

### undefined

느슨한 모드에서는 undefined란 식별자에 값을 할당할 수 있다. 하지만 이는 매우 절대 엄청!!! 비권장 하는 방법

```js
function foo() {
  undefined = 2;
}
foo();

function foo() {
  "use strict";
  undefined = 2; // Type error
}
foo();
```

하지만 모드에 상관없이 `undefined`라는 이름을 가진 지역 변수는 생성할 수 있다. (`var undefined;`와 같이 사용 가능) 이 또한 매우 엄청 절대 !!!! 비권장한다.

### void 연산자

표현식 `void __`는 어떤 값이든 무효로 만들어 항상 결괏값을 undefined로 만든다. 기존 값은 건드리지 않고 연산 후 값은 복구할 수 없다.

void만으로 undefined 값을 나타내려면 `void 0`이라고 사용한다. `void 0, void 1, undefined`는 모두 같다.

void 연산자는 어떤 표현식의 결괏값이 없다는 걸 확실하게 밝혀야 할때 긴요하다.

void 연산자는 값이 존재하는 곳에서 그 값이 undefined가 되어야 좋을 경우에만 사용하도록 하자.

### 특수 숫자

**NaN: Not a Number**
숫자가 아니라는 값이지만, NaN은 유효하지 않은/실패한 숫자/몹쓸 숫자 라는 값으로 정의하는게 좀 더 정확하다.

NaN은 경계값의 일종(특별한 의미를 부여한 평범한 값)으로 숫자 집합 내에서 특별한 종류의 에러 상황을 나타낸다.

```js
var a = 2 / "foo";

a == "NaN"; // false
a === "NaN"; // false
```

NaN은 다른 어떤 NaN과도 동등하지 않다. 자기 자신과도 같지 않다. 반사성 (`x === x`로 식별되지 않는) 이 없는 유일무이한 값이다.
`NaN !== NaN` 이다.

NaN을 확인하는 방법은 `isNaN()`함수를 사용하면 된다.

```js
var a = 2 / "foo";
isNaN(a); // true
```

그러나 isNaN에는 치명적인 결함이 있다. NaN은 너무나 리터럴리하게 해석해 실제 인자 값이 숫자인지 여부를 평가하는 기능이 전부다.

```js
var b = "foo";
isNaN(b); // true
```

이러한 문제를 해결하기 위해 ES6 에서는 `Number.isNaN()`이 등장한다.

```js
var b = "foo";
Number.isNaN(b); // false
```

**무한대**

자바스크립트에서 0으로 나누기를 할 경우 에러가 나타나지 않고 `Infinity`로 나타난다. 분자가 음수면 `-Infinity`로 나타난다.

연산 결과가 너무 커서 표현하기 곤란할 때는 가장 가까운 수로 반올림 모드가 결괏값을 정한다.

무한 / 무한 == 정의되지 않은 연산, NaN
유한한 양수 / 무한대 == 0

**영(0)**

자바스크립트는 일반적인 0(+0)과 음의 영(-0)이 존재한다. 특정 수식의 연산 결과는 -0으로 떨어진다.

```js
var a = 0 / -3; // -0
var b = 0 * -3; // -0
```

그러나 -0을 문자열화 하면 항상 "0"이 된다.

-0이 존재하는 이유는, 값의 크기로 어떤 정보 (예: 애니메이션 프레임당 넘김 속도)와 그 값의 부호로 또 다른 정보(예: 넘김 방향)를 동시에 나타내야 하는 애플리케이션이 있기 때문이다.

-0은 잠재적인 정보의 소싥을 방지하기 위해 존재한다.

-0을 비교하는 방법으로는 `Object.is()` 메서드(두 값이 같은지 확인하는 메서드)를 쓸 수 있다. 해당 메서드는 주로 특이한 동등 비교에 쓴다.

### 값 vs 레퍼런스

자바스크립트는 포인터라는 개념 자체가 없고 참조하는 방법도 조금 다르다. 어떤 변수가 다른 변수를 참조할 수 없다,

자바스크립트에서 레퍼런스는 (공유된) 값을 가리킨다. 서로 다른 10개의 레퍼런스가 있다면 이들은 저마다 항상 공유된 단일 값을 개별적으로 참조한다.

자바스크립트에는 값 또는 레퍼런스의 할당 및 전달을 제어하는 구문 암시가 전혀 없다. 대신, 값의 타입만으로 값-복사, 레퍼런스-복사 둘 중 한쪽이 결정된다.

primitive type같은 단순 값(스칼라 원시 값)은 언제나 값-복사 방식으로 할당/전달 된다. (값-복사 형식은, 특정 값을 복사해 선언한 다음 복사한 값을 변경해도 기존 값은 영향 받지 않음)

객체나 함수같은 합성 값(참조형)은 할당/전달 시 반드시 레퍼런스 사본을 생성한다.

배열과 같은 합성 값을을 복사하려면 손수 값의 사본을 만들어 전달한 레퍼런스가 원본을 가리키지 않게 하면 된다. 예를 들어 인자 없이 `slice()`와 같은 함수를 호출하면 전혀 새로운 배열 (얕은복사)에 의해 사본을 만든다. 이렇게 복사한 사본만을 가리키는 레퍼런스를 전달해 기존에 참조하던 값의 내용을 건드릴 수 없다.

반대로 원시 값을 참조형처럼 바뀐 값이 바로바로 반영되도록 하려면 원시 값을 다른 합성 값(객체, 배열 등)으로 감싸야 한다. 이를 래퍼박싱이라고 한다.

공유된 객체를 가리키는 레퍼런스가 있다고 자동으로 공유된 원시 값을 변경할 권리가 주어지지 않음. 스칼라 원시 값은 불변이다. 스칼라 원시 값을 가진 객체가 있다면, 이와 동일한 객체가 다른 원시값을 가지도록 변경할 수 없다. 단지 다른 값을 넣은, 완전히 별개의 객체를 생성할 수 없다.

## 정리

1. 자바스크립트 배열은 모든 타입의 값들을 숫자로 인덱싱한 집합. 문자열은 일종의 '유사 배열'이지만 배열로 다룰떄는 조심할것.
2. 자바스크립트이 숫자에는 정수/부동 소수점 숫자 모두 포함
3. 원시 타입에는 몇몇 특수값(NaN, 무한대, 0)이 있음
4. void 연산자는 어떤 값이라도 undefined로 만들음
5. 숫자에는 NaN(숫자 아님보단 유효하지 않은 값이 맥락상 더 가까움) +Infinity, -Infinity, -0같은 특수 값이 있음.
6. 단순 스칼라 원시 값(문자열, 숫자 등)은 값-복사에 의해, 합성 값(객체 등)은 레퍼런스-복사에 의해 값이 할당/전달됨. 자바스크립트의 레퍼런스는 다른 언어의 레퍼런스/포인터와는 전혀 다른 개념. 또 다른 변수/레퍼런스가 아닌 오직 자신의 값을 가르킴.

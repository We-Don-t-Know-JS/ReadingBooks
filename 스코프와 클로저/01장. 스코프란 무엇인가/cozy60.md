# 스코프란 무엇인가

## 컴파일러 이론

자바스크립트는 동적 언어로 분류하나 사실은 컴파일러 언어다.
전통적인 컴파일러 언어의 처리 과정에서는 실행되기 전 보통 3단계를 거치는데, 이를 컴파일레이션이라고 한다.

### 토크나이징/렉싱

문자열을 나눠 `토큰`이라 불리는 의미 있는 조각으로 만드는 과정
예를 들어 `var a=2;`라는 프로그램을 봤을때, 이 프로그램은 다음의 토큰으로 나눌 수 있음.

- var,
- a
- =
- 2
- ;

빈칸은 의미에 따라 하나의 토큰일 수도 아닐 수도 있음.

> 토크나이징과 렉싱은 미묘하고 학술적인 차이가 있다. 토큰을 인식할 때 무상태 방식으로 하는지, 상태 유지 방식으로 하는지에 따라 구분함. 쉽게 말해 토크나이저가 상태 유직 파싱 규칙을 적용해 a가 별개의 토큰인지 다른 토큰의 일부인지를 파악하면 렉싱임.
> 토크나이저는 어떤 구문에서 의미있는 요소를 토큰으로 쪼개는 역할을 하고, 렉서는 이러한 토큰의 의미를 분석함.

### 파싱

토큰 배열을 프로그램의 문법 구조를 반영해 중첩 원소를 갖는 트리 형태로 바꾸는 과정
파싱의 결과로 만들어진 트리를 AST(추상 구문 트리)라 부름.

`var a =2;`의 트리는 먼저 변수 선언 이라 부르는 최상위 노드에서 시작하고,
최상위 노드는 `a`의 값을 가지는 `확인자`와 `대입 수식`이라 부르는 자식 노드를 가짐.
대입 수식 노드는 `2`라는 값을 가지는 `숫자 리터럴`을 자식 노드로 가짐.

```
var a = 2;

변수 선언(root)
  ㄴ 확인자
  ㄴ 대입 수식
    ㄴ 숫자 리터럴
```

### 코드 생성

AST를 컴퓨터에서 실행 코드를 바꾸는 과정
자바스크립트 엔진이 기존 컴파일러와 차이점은 자바스크립트 컴파일레이션을 미리 수행하지 않아서 최적화할 시간이 많지 않다는 것
어떤 자바스크립트 조각이라도 실행되려면 먼저 컴파일 되어야 함

## 스코프 이해하기

### 출연진

- **엔진**: 컴파일레이션의 시작부터 끝까지 전 과정과 자바스크립트 프로그램 실행을 책임짐
- **컴파일러**: 파싱과 코드 생성의 모든 잡일을 도맡아 함
- **스코프**: 선언된 모든 확인자(변수) 검색 목록을 작성하고 유지함. 또한 엄격한 규칙을 강제해 현재 실행 코드에서 확인자의 적용 방식을 정함

### 앞과 뒤

`var a = 2;`는 하나의 구문으로 보이나, 엔진은 그렇게 보지 않음. 그러면 엔진과 위의 친구들이 어떻게 접근할까?
이 프로그램에서 컴파일러가 할 일은 (1) 렉싱을 통해 구문을 토큰으로 쪼개는 것 (2) 그 후 토큰을 파싱해 트리 구조로 만들음
그러나 코드 생성 과정에서 컴파일러는 독자의 추측과는 다르게 프로그램을 처리함

컴파일러가 다음 의사 코드로 요약될 수 있는 코드를 생성한다고 생각할 수 있음

> 변수를 위해 메모리를 할당하고, 할당된 메모리를 a라 명명한 후 그 변수에 값 2를 넣음

이는 그닥 정확한 설명이 아님. 컴파일러는 다음 일을 진행함.

1. 컴파일러가 `var a`를 만나면 스코프에게 변수 a가 특정한 스코프 컬렉션 안에 있는지 물음.
   => 변수 a가 이미 있으면..
   컴파일러는 선언을 무시하고 지나감
   => 변수 a가 없으면..
   컴파일러는 새로운 변수 a를 스코프 컬렉션 내에 선언하라고 요청함
2. 그 후 컴파일러는 `a=2` 대입문을 처리하기 위해 나중에 엔진이 실행할 수 있는 코드를 생성함.
   엔진이 실행하는 코드는 먼저 스코프에게 a라 부르는 변수가 현재 스코프 컬렉션 내에서 접근할 수 있는지 확인함.
   => 스코프 컬렉션 내에 접근가능하면..
   엔진은 변수 a를 사용함
   => 스코프 컬렉션 내에 접근할 수 없으면..
   엔진은 다른 곳을 살핌

엔진이 마침내 변수를 찾으면..
=> 변수에 값 2를 넣는다!
못찾으면..
=> 에러 발생!

요약하자면

1. 컴파일러가 변수 선언 (현재 스코프에 미리 변수가 선언되지 않은 경우)
2. 엔진이 스코프에서 변수를 찾고, 변수가 있으면 값을 대입함.

### 컴파일러체

변수 a가 선언된 적이 있는지 스코프에 검색한다. 이때 엔진이 어떤 종류의 검색을 하냐에 따라 검색 결과가 달라진다.

**RHS - Righ- Hand Sdne, 대입한 값**

변수가 대입 연산자의 오른쪽에 있을 때 실행.
RHS 검색은 **단순히 특정 변수의 값을 찾는 것**과 다를 바 없음.
=> RHS 검색은 정확히 말하면 '왼편이 아닌 쪽'이 의미에 좀 더 가까움. 가서 값을 가져와라(Retrieve/his,her/Source)의 약자라고 이해하면 편하다.

예: 구문에서 **a에 아무것도 대입하지 않고, a의 값을 가져와** console.log();에 넘겨준다. 그러므로 아래 구문은 RHS다.

```js
console.log(a);
```

**LHS - Left-Hand Side, 대입할 대상**

변수가 대입 연산자의 왼쪽에 있을 때 수행함.
LHS 검색은 **값을 넣어야 하므로 변수 컨테이너 자체를 찾는다.**

예: 현재 a의 값을 신경 쓸 필요 없이 `= 2`대입 연산을 수행할 대상 변수를 찾는다. 그러므로 아래 구문은 LHS다.

```js
a = 2;
```

> LHS와 RHS가 대입문의 왼쪽/오른쪽을 뜻한다고 해서 반드시 문자 그대로의 방향을 지칭하는 건 아니다. 개념적으로는 대입할 대상(LHS)와 대입한 값(RHS)이라고 생각하는 것이 낫다.

**LHS와 RHS 참조를 모두 수행하는 예**

```js
function foo(a) {
  console.log(a); // 2
}

foo(2);
```

1. 마지막 줄에서 `foo()`함수를 호출하는 데 **RHS 참조**를 사용한다.
   즉, `가서 foo의 값을 찾아 내게 가져와라!`라는 뜻이다.
2. 이때 미묘하지만 중요한 대입이 수행된다. 인수로 값 2를 함수 foo()에 넘겨줄때 **값 2를 인자 a에 대입하는 연산**이 일어난다.
   이 내재된 인자 a에 대한 대입연산을 위해 **LHS 검색**이 수행된다.
3. 변수 a에 대한 **RHS 참조**를 사용한다. 그 결괏값은 console.log()함수에 넘겨진다.
4. console.log()가 실행되려면 참조가 필요하다.
   consol 객체를 **RHS 검색**하여 log메서드가 있는지 확인한다.
5. 마지막으로 값 2를 RHS로 불러온 변수 a를 통해 log()에 넘겨주는 과정에서 LHS/RHS를 주고받는 작업에 대한 개념을 짚어보자.
   구현된 log()내부에는 인자가 있을 것이고, 첫번째 인자를 **LHS 검색**으로 찾아 2를 대입한다.

**함수 선언문**

어쩌면 함수 선언문 `function foo(a) { ... }`를 `var foo`와 `foo = function(a) { ... }`같은 일반적인 변수 선언 및 대입과 같다고 생각할 수 있다.
그러나 여기에는 변수 처리 과정과 다른 미묘하지만 중요한 차이점이 있다.
컴파일러는 앞의 선언문과 값 정의문을 코드 생성 과정에서 처리하여 엔진이 코드를 실행할 때는 foo에 함수값을 대입하는 과정이 필요 없다.
따라서 함수 선언을 앞에서 본 변수의 경우와 같이 LHS 검색 및 대입 과정이라고 생각하는 건 적절하지 않다.

## 중첩 스코프

스코프는 확인자 일므으로 변수를 찾기 위한 규칙의 집합이다.
그러나 대개 고려해야 할 스코프는 여러개다.
하나의 블록이나 함수는 다른 블록이나 함수 안에 중첩될 수 있으므로, 스코프도 다른 스코프안에 중첩될 수 있다.
따라서 대상 변수를 현재 스코프에서 발견하지 못하면 엔진은 바깥의 스코프로 넘어가는 식으로 변수를 찾거나 글로벌 스코프라 부르는 가장 바깥 스코프에 도달할 때 까지 계속한다.

중첩 스코프를 탐사할 때 사용하는 간단한 규칙은 다음과 같다.

- 엔진은 현재 스코프에서 변수를 찾기 시작하고, 찾지 못하면 한 단계식 올라간다.
- 최상위 글로벌 스코프에 도달하면 변수를 찾았든, 못 찾았든 검색 중단

중첩 스코프 규칙을 빌딩으로 이해해보자.
어디에 있든 1층은 현재 실행중인 스코프를 뜻한다.
LHS/RHS를 참조하려면 현재 층을 둘러보고, 찾지 못하면 엘레베이터를 타고 다음 층으로 가서 찾고, 또 다음층으로 이동하는 식이다.
최상위 층(글로벌 스코프)에 도달했을 때 찾던 것을 발견했을 수도 있고 아닐 수도 있다. 어쨌든 검색을 중단한다.

## 오류

LHS와 RHS를 구분하는 것이 왜 중요할까? 이 두 종류의 검색 방식은 변수가 아직 선언되지 않았을 때(검색한 모든 스코프에서 찾지 못했을 때) 서로 다르게 동작하기 때문이다.

```js
function foo(a) {
  console.log(a + b);
  b = a;
}

foo(2);
```

b에 대한 첫 RHS 검색이 실패하면 다시는 b를 찾을 수 없다.
이렇게 스코프에서 찾지 못하는 변수는 **선언되지 않은 변수**라고 한다. RHS 검색이 중첩 스코프 안 어디에서도 변수를 찾지 못하면 엔진이 **ReferenceError**를 발생시킨다. 여기서 중요한 점은 오류가 ReferenceError타입이라는 것이다.

반면, 엔진이 LHS 검색을 수행해 변수를 찾지 못하고 최상위 층(글로벌 스코프)에 도착할 때 프로그램이 엄격 모드가 아니면 **글로벌 스코프는 엔진이 검색하는 이름을 가진 새로운 변수를 생성해 엔진에게 넘겨준다.** 즉, 없었지만 내가 널 위해 하나 만들어주지- 라고 생각하면 된다.

ES5부터 지원하는 엄격 모드는 여러 면에서 다르게 작동된다.
예를 들어, 엄격 모드에서는 글로벌 변수를 자동으로 또는 암시적으로 생성할 수 없다. 그래서 앞의 상황이 닥치면 글로벌 스코프는 변수를 생성하지 않아 LHS 검색은 아무것도 얻지 못하고, 엔진은 RHS의 경우와 비슷하게 ReferenceError를 발생시킨다.

RHS 검색 결과 변수를 찾았지만 그 값을 가지고 불가능한 일을 하려고 할 경우(함수가 아닌 값을 함수처럼 실행하거나, null이나 undefined 값을 참조할 때)엔진은 TypeError를 발생시킨다.
`ReferenceError`는 **스코프에서 대상을 찾았는지**와 관계있지만, `TypeError`는 **스코프 검색은 성공했으나 결괏값을 가지고 적합하지 않거나 불가능한 시도**를 할 경우를 의미한다.

## 정리하기

- 스코프는 어디에서 어떻게 변수(확인자)를 찾는가를 결정하는 규칙의 집함. 변수를 멋개하는 이유는 변수에 값을 대입하거나 변수의 값을 얻어오기 위해서임.
- LHS 참조는 대입 연산 과정에서 일어남. 스코프와 관련된 대입 연산은 `=`연산자가 사용되거나 인자를 함수의 인자로 넘겨줄때 일어남.
- 자바스크립트 엔진은 코드를 실행하기 전에 먼저 컴파일하는데, 이 과정에 엔진은 `var a = 2;`와 같은 구문을 독립된 두 단계로 나눈다.

1. var a는 변수 a를 해당 스코프에 선언한다. 이 단계는 코드 실행 전에 처음부터 수행된다.
2. a = 2는 변수 a를 찾아 값을 대입한다.
3. LHS와 RHS 참조 검색은 모두 현재 실행중인 스코프에서 시작한다. 그리고 필요하다면 (대상 변수를 찾지 못했을 경우) 한 번에 한 스코프씩 중첩 스코프의 상위 스코프로 넘어가며 확인자를 찾는다.
   이 작업은 글로벌 스코프에 이를 때까지 계속하고 대상을 찾았든, 못 찾았든 작업을 중단한다.
4. RHS 참조가 대상을 찾지 못하면 - ReferenceError
   LHS 참조가 대상을 찾지 못하면 - 자동적으로 글로벌 스코프에 같은 이름으로 새로운 변수 생성. 단, 엄격 모드일 경우 ReferenceError 발생

# 함수 vs 블록 스코프

스코프는 컨테이너 또는 바구니 구실을 하는 일련의 '버블'이고 변수나 함수 같은 확인자가 그 안에서 선언된다. 이 버블은 경계가 분명하게 중첩되고, 그 경계는 개발자가 코드를 작성할 때 결정된다.

그렇다면 어떤 것이 새로운 버블을 생성할까?

## 함수 기반 스코프

함수 스코프의 예시

```js
function foo(a) {
  var b = 2;
  // some code
  function bar() {
    // ...
  }
  // more code
  var c = 3;
}
```

앞의 코드에서 foo()의 스코프 버블은 확인자 a, b, c와 bar를 포함한다.
선언문이 스코프의 어디에 있는지는 중요하지 않다.
**스코프 안에 있는 모든 변수와 함수는 그 스코프 버블에 속한다.**

bar()는 자체 스코프 버블이 있고 글로벌 스코프도 마찬가지다. 그리고 글로벌 스코프에는 하나의 확인자가 있는데, 바로 foo다.
a, b, c, bar 모두 foo()의 스코프 버블에 속하므로 foo() 바깥에는 이들에게 접근할 수 없다. 따라서 다음 코드는 확인자가 글로벌 스코프에는 없기 때문에 ReferenceError 오류를 발생시킨다.

```js
bar();
console.log(a, b, c);
```

**함수 스코프는 모든 변수가 함수에 속하고 함수 전체(중첩된 스코프에서도)에 걸쳐 사용되며 재사용된다는 개념을 확고하게 한다.**
이러한 접근법은 자바스크립트 변수의 동적 특성을 완전히 살려 유용하게 쓸 수 있지만, 스코프 전체에 변수가 살아있다는 점이 예상치 못한 문제를 일으킬 수도 있다.

## 일반 스코프에 숨기

함수에 대한 전통적인 개념은 아래와 같다.

- 함수를 선언하고 그 안에 코드를 넣는다. 바꿔 생각하는 것도 유용하다.
- 작성한 코드에서 임의 부분을 함수 선언문으로 감싼다. 이는 해당 코드를 숨기는 효과를 낸다.

이렇게 하면 해당 코드 주위에 새로운 스코프 버블이 생성된다. 즉, 감싸진 코드 안에 있는 모든 변수 또는 함수 선언문은 이전 코드에 포함됐던 스코프가 아니라 새로이 코드를 감싼 함수의 스코프에 묶인다.
달리 말하면, 함수의 스코프로 둘러싸서 변수와 함수를 숨길 수 있다는 말이다.

## 코드를 숨기는 테크닉

스코프를 이용해 숨기는 방식을 사용하는 이유는 여러가지가 있다. 그중 하나는 소프트웨어 디자인 원칙인 **'최소 권한의 원칙(최소 권위 또는 최소 노출)'** 과 관련이 있다. 이 원칙은 모듈/객체의 API와 같은 소프트웨어를 설계할 때 필요한 것만 최소한으로 남기고 나머지는 숨겨야 한다는 것이다.
접근 가능한 확인자는 의도적이든 아니든 생각지 못한 방식으로 사용될 수 있다.

다른 장점은 **같은 이름을 가졌지만 다른 용도를 가진 두 확인자가 충돌하는 것을 피할 수 있다는 점**이다.

### 글로벌 네임스페이스

글로벌 스코프에서 변수 충돌이 특히 일어나기 쉬운 경우가 있다. 바로 내부/비공개 함수와 변수가 적절하게 숨겨지 않은 여러 라이브러리를 한 프로그램에 불러오면 라이브러리들은 서로 쉽게 충돌한다.
이런 라이브러리는 일반적으로 글로벌 스코프에 하나의 고유 이름을 가지는 객체 선언문을 생성한다. 이후 객체는 해당 라이브러리의 '네임스페이스'로 이용된다.
네임스페이스를 통해 최상위 스코프의 확인자가 아니라 속성 형태로 라이브러리의 모든 기능이 노출된다.

```js
var MyReallyCoolLibrary = {
  awesome: "stuff",
  doSomething: function () {
    // ...
  },
  doAnotherThing: function () {
    // ...
  },
};
```

### 모듈 관리

좀 더 현대적인 충돌 방지 옵션으로는 다양한 의존성 관리자를 이용한 모듈 접근법이 있다. 이 도구를 사용하면 어떤 라이브러리도 확인자를 글로벌 스코프에 추가할 필요 없이, 특정 스코프로부터 의존성 관리자를 이용해 다양한 명시적인 방법으로 확인자를 가져와 사용할 수 있다.

## 스코프 역할을 하는 함수

함수의 스코프 안에 동일한 이름을 가진 변수를 선언하는 건 실행은 되지만 이상적인 방식은 아니다. 해당 함수를 선언해야 하므로 글로벌 스코프를 오염시킬 수 있고, 그 함수를 직접 이름으로 호출해야만 실제 감싼 코드를 실행할 수 있따.
이러한 함수를 이름 없이 선언하고 자동으로 실행하게 할 수 있는데, IIFE와 익명 함수를 사용하는 방법이 있다.

### IIFE - Immediately Invoked Function Expression

Immediately Invoked Function Expression
즉시 호출 함수 표현식

```js
var a = 2;

// 함수가 (function ... 으로 시작한다.
// 이는 보통의 함수 선언문이 아닌 함수 표현식으로 취급된다.
// 함수 자신의 내부 스코프에 묶인다.
// 즉, 확인자 foo는 오직 { } 내부에서 가리키는 스코프에서만 찾을 수 있고,
// 바깥 스코프에서는 발견되지 않는다.
(function foo() {
  var a = 3;
  console.log(a); // 3
})();
// 함수 foo를 자기 내부에 숨기면 함수를 둘러싼 스코프를 불필요하게 오염시키지 않는다.

console.log(a);
```

()로 함수를 감싸면 함수를 표현식으로 바꾸는데, `(function foo() { }) ()`처럼 마지막에 또 다른 ( )를 붙이면 함수를 실행할 수 있다.
IIFE는 이름이 꼭 필요하지 않다. 익명 함수 표현식으로 가장 흔하게 사용된다.
전통적인 IIFE 형태를 약간 변형해 `(function foo() { } ())`로 사용하기도 한다. 두 형태 모두 같이 기능한다.

### 익명 vs 기명

함수 표현식을 콜백 인자로 사용하는 사례

```js
setTimeout(function () {
  console.log("I waited 1 second!");
}, 1000);
```

이러한 방식은 **익명 함수 표현식**이라 부른다. 함수 표현식은 이름 없이 사용할 수 있지만, 함수 선언문에는 이름이 빠져서는 안된다. 그러므로 이는 함수 표현식이다.

## 스코프 역할을 하는 블록

블록 스코프의 목적은 **변수를 최대한 사용처 가까이에서 최대한 작은 유효 범위를 갖도록 선언하는 것** 이다. 예를 들자면 `for (var i=0; i<10; i++)`같은 코드가 있다.
선언된 변수는 항상 둘러싸인 스코프에 속하기 때문에 '최소 권한 노출의 원칙'을 지키게 된다. 정보를 함수 안에 숨기고, 나아가 정보를 코드 블록 안에 숨기기 위한 도구다.
블록 스코프를 사용했다면 변수 i는 오직 for 반복문 안에서만 사용할 수 있고, 이외 함수 어느 곳에서 접근하더라도 오류가 발생할 것이다. 이는 변수가 혼란스럽고 유지 보수하기 어려운 방식ㄷ으로 재사용되지 않도록 막는다.

### with

with문 안에 생성된 객체는 바깥 스코프에 영향 주는 일 없이 with문이 끝날 때까지만 존재한다.

### try/carch

catch문의 error는 오직 catch 문 안에서만 존재하므로 다른 곳에서 참조하려면 오류가 난다.

### let

let은 var 같이 변수를 선언하는 다른 방식이다. 키워드 let은 선언된 변수를 둘러싼 아무 블록(일반적으로 {})의 스코프에 붙인다. let 선언문은 둘러싼 함수 (또는 글로벌) 스코프가 아니라 가장 가까운 임의의 블록에 변수를 붙인다.
바꿔 말해, 명시적이진 않지만 let은 선언한 변수를 위해 해당 블록 스코프를 이용한다고도 말할 수 있다.
그저 { }를 문법에 맞게 추가만 해도 let을 통해 선언된 변수를 묶을 수 있는 임의의 블록을 생성할 수 있다.

```js
{
  console.log(bar); // ReferenceError!
  let bar = 2;
}
```

let을 사용한 선언문은 속하는 스코프에서 호이스팅 효과를 받지 않는다. 따라서 let으로 선언된 변수는 실제 선언문 전에는 명백하게 '존재'하지 않으므로, ReferenceError가 나타나게 된다.

### 가비지 콜렉션

블록 스코프가 유용한 또 다른 이유는 메모리를 회수하기 위한 클로저 그리고 가비지 콜렉션과 관련 있다.

```js
function process(data) {
  // do something interesting
}

var someReallyBigData = { ... };

process(someReallyBigData);

var btn = document.getElementById("my_button");

// click 함수는 someReallyBigData가 전혀 필요 없다.
// 따라서 이론적으로는 process()가 실행된 후 많은 메모리를 먹는 자료구조인 someReallyBigData는 수거할 수도 있다.
// 그러나 자바스크립트 엔진은 그 데이터를 여전히 남겨둔다.
// click 함수가 해당 스코프 전체의 클로저를 가지고 있기 때문이다.
btn.addEventListener("click", function click(evt) {
  console.log("button clicked");
}, false)
```

블록 스코프는 엔진에게 someReallyBigData가 더는 필요 없다는 사실을 더 명료하게 알려서 이 문제를 해결할 수 있다.

```js
function process(data) {
  // do something interesting
}

{
  let someReallyBigData = { ... };
  process(someReallyBigData);
}

var btn = document.getElementById("my_button");

btn.addEventListener("click", function click(evt) {
  console.log("button clicked");
}, false)
```

### const

const 역시 블록 스코프를 생성하지만, 선언된 값은 고정된다.

## 정리하기

- 자바스크립트에서 함수는 스코프를 이루는 가장 흔한 단위다. 다른 함수 안에서 선언된 변수와 함수는 본질적으로 다른 '스코프'로부터 '숨겨진' 것이다.
- 함수는 결코 유일한 스코프 단위가 아니다. 블록 스코프는 함수만이 아니라 임의의 코드 블록에 변수와 함수가 속하는 개념이다.
- 블록 스코프는 var 함수 스코프를 완전히 대체할 수 없다. 두 기능은 공존하며 이 두 기술을 같이 사용할 수 있어야 한다.

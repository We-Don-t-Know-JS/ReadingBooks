# 스코프 클로저

## 핵심

> 클로저는 함수가 속한 렉시컬 스코프를 기억해 함수가 렉시컬 스코프 밖에서 실행될 때에도 이 스코프에 접근할 수 있게 하는 기능을 뜻한다.

```js
function foo() {
  var a = 2;
  function bar() {
    console.log(a); // 2
  }
  bar();
}

foo();
```

함수 bar()는 렉시컬 스코프 검색 규칙을 통해 바깥 스코프의 변수 a에 접근할 수 있다.
함수 bar()는 foo() 스코프에 대한 클로저를 가진다. (물론 bar()는 그 외의 접근 가능한 스코프에 대한 클로저도 가진다.)
달리 말하면 bar()는 foo() 스코프에서 닫힌다. bar()는 중첩되어 foo() 안에 존재하기 때문이다.

```js
function foo() {
  var a = 2;
  function bar() {
    console.log(a);
  }
  return bar;
}

var baz = foo();
baz();
```

함수 bar()는 foo()의 렉시컬 스코프에 접근할 수 있고, bar() 함수 자체를 값으로 넘긴다. 이 코드는 bar를 참조하는 함수 객체 자체를 반환한다.

foo()를 실행해 반환한 값을 baz라 불리는 변수에 대입하고, 실제로는 baz()함수를 호출했다. 이는 내부 함수인 bar()를 호출한 것이다. 그러나 이 경웨 함수 bar는 함수가 선언된 렉시컬 스코프 밖에서 실행됐다.

일반적으로 foo()가 실행된 후에는 foo()의 내부 스코프가 사라진다고 생각한다. 그러나 클로저의 마법이 이를 내버려두지 않는다. foo의 내부 스코프는 여전히 사용 중 이므로 해제되지 않는다. 해제되지 않는 스코프를 bar() 자신이 사용한다.

선언된 위치 덕에 bar()는 foo() 스코프에 대한 렉시컬 스코프 클로저를 가지고, foo()는 bar()가 나중에 참조할 수 있도록 스코프를 살려둔다. foo() 선언이 끝나고 수 밀리 초 후 변수 baz를 호출할 때, 해당 함수는 원래 코드의 렉시컬 스코프에 접근할 수 있고, 이는 함수가 변수 a에 접근할 수 있다는 의미다.

함수는 원래의 렉시컬 스코프에서 완전히 벗어나 호출됐다. 클로저는 호출된 함수가 원래 선언된 렉시컬 스코프에 계속해서 접근할 수 있도록 허용한다. **어떤 방식이든 함수를 값으로 넘겨 다른 위치에 호출하는 행위는 모두 클로저가 작용한 예다.**

```js
function foo() {
  var a = 2;
  function baz() {
    console.log(a); // 2
  }
  // 함수 baz를 bar에 넘기고,
  bar(baz);
}

function bar(fn) {
  // fn이라고 명명된 함수를 호출
  // 이때 foo()의 내부 스코프에 대한 fn의 클로저는 변수 a에 접근할 때 확인할 수 있다.
  fn(); // 클로저
}
```

## 이제 나는 볼 수 있다

### 사례 1

```js
function wait(message) {
  setTimeout(function timer() {
    console.log(message);
  }, 1000);
}

wait("Hello, closure!");
```

내부 함수 timer를 setTimeout()의 인자로 넘겼다. timer 함수는 wait() 함수의 스코프에 대한 스코프 클로저를 갖고 있으므로 변수 message에 대한 참조를 유지하고 사용할 수 있다.

자체의 렉시컬 스코프에 접근할 수 있는 함수를 인자로 넘길 때 그 함수가 클로저를 사용하는 것을 볼 수 있다. 타이머, 이벤트 처리기, Ajax 요청, 윈도 간 통신, 웹 워커와 같은 비동기적(또는 동기적) 작업을 하며 콜백 함수를 넘기면 클로저를 사용할 준비가 된 것이다.

### 사례 2

```js
var a = 2;

(function IIFE() {
  console.log(a);
})();
```

이 코드는 엄격히 말해 클로저가 사용된 것은 아니다. 함수 IIFE가 자신의 렉시컬 스코프 밖에서 실행된것이 아니기 때문이다. IIFE 함수는 선언된 바로 그 스코프 안에서 호출됐다. (a를 들고 있는 둘러싼 스코프와 글로벌 스코프) 변수 a는 클로저가 아니라 일반적인 렉시컬 스코프 검색을 통해 가져왔다.

### 사례 3 - 반복문과 클로저

```js
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```

이 코드의 목적은 1부터 5까지 한번에 하나씩 일 초마다 출력하는것이다. 그러나 셀지 값은 일초마다 한번씩 6만 5번 출력된다.
이는, 반복문이 끝나는 조건은 i가 <=5가 아닐 때다. 처음으로 끝나는 조건이 갖춰졌을 때 i의 값은 6이다. 즉, 출력된 값은 반복문이 끝났을 때의 i값을 반영한 것이다.
이때 필요한 것은 반복마다 각각의 i 복제본을 잡아두는 것이다. 그러나 반복문 안 총 5개의 함수들은 반복마다 따라 정의됐음에도 모두 같이 글로벌 스코프 클로저를 공유해 해당 스코프 안에는 오직 하나의 i만이 존재한다. 따라서 모든 함수는 당연하게도 같은 i에 대한 참조를 공유한다. 이때 필요한 것은 더 많은 닫힌 스코프다. 반복마다 하나의 새로운 닫힌 스코프가 필요하다.

```js
for (var i = 1; i <= 5; i++) {
  // IIFE는 함수를 정의하고 바로 실행시키면서 스코프를 생성한다.
  // 각각의 timeout 함수 콜백은 반복마다 각각의 IIFE가 생성한 자신만의 스코프를 가진다.
  (function () {
    // 그러나 이 스코프는 비어있기에 반복마다 i의 값을 저장할 변수가 필요하다.|
    var j = i;
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })();
}
```

### 다시 보는 블록스코프

```js
for (var i=1; i<=5; i++) {
  let j = i;
  setTimeout(function timer() {
    console.log(j);
  }, j*1000);
}
```
```js
  for (let i=1; i<=5; i++) {
    setTimeout(function timer() {
      console.log(j);
    }, i*1000);
  }
```

let 선언문이 for 반복문 안에서 사용되면 특별한 방식으로 작동된다. 반복문 시작 부분에서 let으로 선언된 변수는 한 번만 선언되는 것이 아니라 반복할 때마다 선언된다. 따라서 해당 변수는 반복마다 이전 반복이 끝난 이후의 값으로 초기화 된다.

## 정리하기

클로저는 함수를 렉시컬 스코프 밖에서 호출해도 함수는 자신의 렉시컬 스코프를 기억하고 접근할 수 있는 특성을 의미한다.
반복문을 예로 들면, 클로저를 통해 설사 우리가 기억하지 못했을지라도 반복문이 어떻게 작동하는지 추적해갈 수 있다.